# 包

也就是代码复用 多个代码的集合 可以理解为 python的库

`go env`

我们可以看到 GOPATH

`set GOPATH=C:\Users\X\go`

如何切换到 我们实际的 工作目录 这样 go install 都会下到新的GOPATH

# 标准引用

通过 import 导入的 内容就是标准引用

```
import (
	"fmt"
	"os/exec"
)
```

# 别名引用

```
import F "fmt"
import . "fmt" //省略引用格式
```

这个时候 通过F 就可以调用 fmt的内容

如果我们通过省略引用格式 那么我们直接通过 

```
Println("hellow world")
```

就可以调用

# 自定义包

首先 包我们都是通过目录命名的

`一个包的多个函数 定义在一个目录下面`

首先设置前提 我们需要打开`GO111MODULE=on`模式

```
go mod init test // 设置当前项目的 名字
```

./Add/sum.go

```go
package Add

import "fmt"

func init() {
	fmt.Println("sum init")
}

func Add(a, b int) int { //外部 需要大写
	return a + b
}

```

./main.go

```go
package main

import (
	"fmt"
	"test/Add" //通过项目名字导入包
)

func main() {
	fmt.Println(Add.Add(1, 2))
}

```

## 只需要执行init

如果我们只需要执行 init函数

```
import _ "test/Add"
```

一个包最好是一个 init 不要多个

这里我是通过放弃 GOPATH方法 而是通过 GO mod方法

# 包内包外

对于函数 如果希望可以被外部调用 那么就通过包内大写

否则 如果是小写 就只能在自己包内使用

# Go包的管理

从 单一全部 包都在GOPATH的src目录下 

到 go vendor 每个目录管理 如果开源 所有都需要打包上传

最后是 go mod  当打开后 忽略 GOPATH 和 vendor 自动去go mod 下载依赖包

```
//go mod 管理
go env -w GO111MODULE="on"
go mod init 项目名字 //这里就为本地项目命名
go mod tidy //自动扫描下载 依赖 
```

go.mod

```
//这里管理所有包的内容
module test

go 1.24.5
```

GOPATH目录就存入的是 函数

