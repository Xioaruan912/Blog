# 数据类型



win32具有自己的数据类型 这篇主要就是直接了解 win32的自己数据类型

虽然是自己的数据类型 其实本质上就是 C语言内部的 数据类型

1. 大小在所有windows上是固定的 定义的` int32`或者`64`都是固定大小 但是C语言在不同平台上 的`int` `long` 可能是不同的
2. 学习`win32`数据类型 可以确保在 `32或者64位机器`上 保证`数据一致` 32位机器无法执行64位的软件
3. `win32`的数据类型 一般都是全部大写

# 错误处理

win32 消息传递 一般都是通过 错误码传递信息 所以我们需要对 错误进行正确处理 这样才可以实现

我们可以通过一个` CreateFileA`  函数进行测试

![image-20260202172256204](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260202172256204.png)

```c++
#include <Windows.h>
#include <stdio.h>


void CreateFileByWin32(const char* filepath) {
	HANDLE hFile = CreateFileA(
		filepath,
		GENERIC_READ,
		0,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		0
	);
	if (hFile == INVALID_HANDLE_VALUE) {
		DWORD dwError = GetLastError(); // 获取错误码
		printf("%d", dwError);
	}
}

int main()
{
	CreateFileByWin32("C:\\1.txt");
	return 0;
}
```

这里注意 由于入口是 `main` 所以是一个 `CPP`

输出结果是 `2`

![Capturer_2026-02-02_215903_744](https://raw.githubusercontent.com/Xioaruan912/pic/main/Capturer_2026-02-02_215903_744.gif)

# 错误信息

win32函数一般返回值如下

`NULL` `FASLE` `INVALID_HANDLE_VALUE`

如果函数返回错误 可以通过 `GetLastError()` 获得错误 这个方法 获取的是 堆栈最后返回的错误

我们可以通过 `FormatMessage()` 把  `GetLastError()` 错误数字 转化为 错误信息

`MessageBox()` 可以用于展现信息

```C
#include <Windows.h>
#include <stdio.h>


//这里都是固定格式 可以通过 F1 找到
void PrintError() {
	DWORD dError = GetLastError();
	LPVOID lpBuffer = NULL;
	//固定格式 API手册里木有
	FormatMessageA(
		FORMAT_MESSAGE_ALLOCATE_BUFFER |
		FORMAT_MESSAGE_FROM_SYSTEM,
		NULL,
		dError,
		MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
		(LPSTR)&lpBuffer,
		0,
		NULL);
	printf("%d", dError);
	printf("%s", (LPSTR)lpBuffer);

	//释放内存
	LocalFree(lpBuffer);
}


void QuitProcess(DWORD dwProcess) {
	//获取进程的句柄
	HANDLE hProcess = OpenProcess(
		PROCESS_ALL_ACCESS,  //获得全部权限
		FALSE,  // 不允许被继承
		dwProcess
	);
	//错误处理
	if (hProcess == NULL) {
		PrintError();
	}

	//关闭一个进程
	BOOL ok = TerminateProcess(
		hProcess,
		2000 // 设置退出码
	);
	if (ok == 0) {
		PrintError();
	}
	//关闭句柄
	BOOL BcloseHandle = CloseHandle(hProcess);
	if (BcloseHandle == 0) {
		PrintError();
	}
}



int main()
{
	DWORD dwProcess;
	printf("输入 要关闭的进程ID");
	scanf_s("%d", &dwProcess);
	QuitProcess(dwProcess);
	return 0;
}
```

这样就构建了一个 关闭进程的方法 并且通过`FormatMessageA` 输出错误内容
