实习逆向分析过程中 遇见 C++ 程序概率很大 所以我们起码需要了解一些机制处理

# 构造函数

在定义对象过程中 定义出构造函数 可以初始化对象

1. 函数名字和 类名字一样 没有返回类型
2. 用于对象初始化
3. 创建对象自动调用
4. 如果不写 编译器默认构建一个 没有参数的 构造函数

```c
class Child{
public:
	Child(int a,char s){
		age = a;
		sex = s;
	}
public:
	int age; 
	char sex;
};

```

## 创建对象的方法

如果我们通过 `new` 那么就会构建在 `堆内存`中  这里是动态创建 并且返回指针

![image-20260124093429435](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124093429435.png)

如果我们通过 普通类型一样 定义 那么就会被构建在 `栈内存`中

![image-20260124093420387](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124093420387.png)

如果我们做网络编程开发 需要对网络数据包 动态调整大小 那么我们需要把数据定义在`堆`中

我们看看反汇编下 这两个方法的内容

```c
#include <stdio.h>
class Child{
public:
	Child(int a,char s){
		age = a;
		sex = s;
		printf("enter child \n");
	}

public:
	int age; //4字节
	char sex; //1字节
};


int main(){
	Child c(1,'0');
	//Child *childptr = new Child(1,'0');
	return 0;
}
```

汇编如下

```c
17:       Child c(1,'0');
00401038   push        30h
0040103A   push        1
0040103C   lea         ecx,[ebp-8]
0040103F   call        @ILT+5(Child::Child) (0040100a)
18:       //Child *childptr = new Child(1,'0');
19:       return 0;
00401044   xor         eax,eax
```

`lea` 作用是` load effective address` 加载有效地址 也就是传递 `this` 关键字的地址

我们看看另一个通过 `new`方法构建的

```c
int main(){
	//Child c(1,'0');
	Child *childptr = new Child(1,'0');
	return 0;
}
```

下面是汇编指令 可以发现 多了这么多

```
18:       Child *childptr = new Child(1,'0');
0040104D   push        8
0040104F   call        operator new (004011f0)  
00401054   add         esp,4  //调用 new函数并且 通过 __cdecall 标准 让调用者 清理内存
00401057   mov         dword ptr [ebp-18h],eax  //结果存入局部变量
0040105A   mov         dword ptr [ebp-4],0  //0存入局部变量
00401061   cmp         dword ptr [ebp-18h],0 //比较 0值
00401065   je          main+58h (00401078)
00401067   push        30h
00401069   push        1
0040106B   mov         ecx,dword ptr [ebp-18h]
0040106E   call        @ILT+5(Child::Child) (0040100a)  //调用构造函数
00401073   mov         dword ptr [ebp-1Ch],eax
00401076   jmp         main+5Fh (0040107f)
00401078   mov         dword ptr [ebp-1Ch],0
0040107F   mov         eax,dword ptr [ebp-1Ch]
00401082   mov         dword ptr [ebp-14h],eax
00401085   mov         dword ptr [ebp-4],0FFFFFFFFh
0040108C   mov         ecx,dword ptr [ebp-14h]
0040108F   mov         dword ptr [ebp-10h],ecx
19:       return 0;
00401092   xor         eax,eax

```

可以发现就两个步骤

1. 通过new 动态构建
2. 调用 构造函数

# 析构函数

作用和构造函数相反 主要是在结构体生命 结束的时候执行

1. 与对象名字一样 多了个 `~`符号
2. 用于对象清理
3. 会默认构建

```c
#include <stdio.h>
class Child{
public:
	Child(int a,char s){
		age = a;
		sex = s;
		printf("enter child \n");
	}
public:
	~Child(){
		printf("enter ~child \n");
	}
public:
	int age; //4字节
	char sex; //1字节
};


int main(){
	//Child c(1,'0');
	Child *childptr = new Child(1,'0');
	delete childptr;
	return 0;
}
```

# 虚函数【暂时没有搞清楚】

面向对象编程 具有三大特性

1. 封装性
2. 继承性
3. 多态性：允许不同类的对象 对同一消息 响应 也即是 一个接口 多个方法 通过虚函数实现

```c
#include <stdio.h>
class OSbase{
public: //基本类中 定义出一个虚函数 并且是纯虚函数
	virtual int create_process() = 0 ;
};


//用 win32OS类 继承 基本类
class Win32OS : public OSbase{
public:
	//实现 虚函数的内容
	virtual int create_process(){
		printf("enter Win32\n");
		return 0;
	}
};

//定义一个宏 用于分析是不是win32
OSbase* CheckOS(){
#ifdef WIN32
	return new Win32OS
#endif
}

int main(){
	//通过宏 分析是不是 win32 如果是 就返回Win32OS类
	OSbase* os = CheckOS();
	//通过Win32OS 类 执行虚函数
	os->create_process();
	return 0;
}
```

上述代码就是一个多态的 我们可以通过 基本类 以及其他类 去访问 虚函数

我们通过汇编分析一下

```
28:       //通过Win32OS 类 执行虚函数
29:       os->create_process();
00401200   mov         eax,dword ptr [ebp-4]  //这里就是 os 这个局部变量 存入eax
00401203   mov         edx,dword ptr [eax]  //访问这个局部变量的 第一个内容 存入edx中
00401205   mov         esi,esp
00401207   mov         ecx,dword ptr [ebp-4]
0040120A   call        dword ptr [edx]  //调用edx函数

```

通过这个操作 可以分析出 `os`的第一个成员就是 虚函数表的指针 通过访问虚函数表 从而实现虚函数的执行
