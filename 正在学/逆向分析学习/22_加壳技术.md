SMC也就是我们的 自吐类

加壳也是静态保护的一种

没有壳的时候 反编译软件 一下就可以直接反汇编 甚至可以反汇编出 高级语言

如果加了壳 再反汇编 那么就只能看见壳

![image-20260211110554048](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211110554048.png)

从而出现了 加壳和脱壳两个技术 现在主要有下述几个壳：

`压缩壳`：加密只是辅助 主要是为了压缩内容 例如木马加入office 文档中 太大就会被发现  `UPX`和`ASPack` 是比较常见的

`加密壳`：主要对程序进行加密 混淆 花指令 反调试等技术 综合运用 `ASProtect` `Armadillo` `Themida` `Winlicense` 比较常见

`虚拟机壳`：最难的情况 构建虚拟指令集 `VMP`

# 壳的基本原理

![image-20260211110955674](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211110955674.png)

这个是一个PE文件

1. 对PE文件的每一个节 都进行 压缩加密
2. 插入一个壳节 用于解密还原源代码
3. 修改入口地址 转向新的节

![image-20260211111106740](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211111106740.png)

在执行过程中 壳节首先执行 进行解压和解密 还原源PE文件 从而实现程序的执行 最后跳转源OEP处 实现软件的运行

# 最简单的壳

首先我们需要分析一下加壳过程

1. 打开PE文件 获取节表和节 对节进行加密
2. 解密代码 对PE进行遍历 实现解密
3. 解密代码编译后 扣出 十六进制代码 最后加入一个 跳转指令 写入最后一个新的节 
4. 源PE文件的节表头 增加一个表项 把新的节信息填写 更新节的数量
5. 修改PE的入口地址

## 需要处理的内容

1. 导入表内容：由于加密了 win在执行过程 不知道要导入什么模块 从而报错 所以这个需要特殊处理

处理方法一般是 加密原本导入表 在本节中增加一个新的导入表 最后 修改数据目录导入表的地址

在运行过程中 不仅需要解密 还需要担任WIN加载器 加载原本的DLL

