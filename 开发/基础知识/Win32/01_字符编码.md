# ASCII编码

通过编码进行 对应字符串  使用一个字节进行表示 那么最多只能表示 `255个`

![image-20250308175200946](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20250308175200946.png)

在我们输入计算机  `A` 的时候 实际上写入的是 十进制 `65`

# GB2312 / GB2312-80

使用 255 无法满足汉字 在标准`ASCII` 里 我们只用了 `7F`  所以 `80 - FF` 我们是没有使用的 那么这个`GB2312` 就是通过扩展 标准`ASCII` 实现

 使用`两个 扩展ASCII表` 组合两个字节 生成一个汉字

# UNICODE

使用上面的话 每个国家都有自己的方法 这样我们计算机就需要存储全世界的编码格式 那么就乱套了 

所以后期通过世界规范出了`unicode`编码

总的来说 全世界统一的编码

编码范围 `0 - 0x10FFFFF` 足够容纳

但是`Unicode` 也有没有解决的问题  例如

```
中 ----- 0x 12 33 占4字节
国 ----- 0x 22 占2字节
```

同样的语言 `unicode` 只负责编码 不在乎如何存储 这样就没有规范

# UTF-8/UTF-16

## UTF-16

`UTF - 8/16` 的出现就是为了解决 `unicode`遗留问题 他们是 `unicode` 的实现方法

`UTF-16` 使用 `16位无符号`存储 占`2字节`    但是如果超过了 那么就允许`最大4字节`

 但是 `unicode` 默认使用 `UTF-16` 存在弊端 例如我们 传递`A` 我们知道 传递的是 `0x41` 但是如果使用 `UTF-16` 传递的就是 `0x0041` 

在网络传输中 需要额外添加 一字节 造成浪费 所以产生了 `UTF-8`

## UTF-8

他规定 如果 1字节能传递完就使用1字节 不进行扩展 按照你的编码传递   使用变长编码 是计算机网络里面的那个  

![image-20250308182148498](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20250308182148498.png)

如何识别使用什么编码 在文件头添加编码识别

![image-20250308182320995](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20250308182320995.png)