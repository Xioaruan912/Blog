在go中 我们其实多使用切片 slice 

1. 长度不固定
2. 但是需要存放同一类型
3. 最底层是数组

# 切片的定义

```
var 名字 []类型
```

可以发现不需要写 大小了 编译器自己推断

```
var A []string 
```

上述定义了 字符串的切片

# 初始化

数组初始化：

```
var A []string{"A"}
```

通过数组从而获取切片：

```
var A [3]string{"A","B","C","D"}
b := A[:3]
```

这样我们就可以得到一个 类型为 `string`的b切片 这里是可以看作切分 并且是`左闭右开`的` [0,3) `所以我们得到的内容是` 0,1,2 `下标的内容

通过切片从而获取切片：

```
c := b[:]
```

这样我们可以得到一个 和b完全相同的 c切片

【推荐】通过make函数构造切片：

```
c := make([]string,4,4)
```

```
make(类型，长度，切片的容量)
```

长度：切片要放多少个元素

切片的容量：底层的数组 大小是多少 （可以省略）如果省略 就和长度一致

# 切片的本质

![image-20260101122858242](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260101122858242.png)

切片就是一个封装好的结构体 有一个指针指向 底层数组 存入多少内容 就是`len` 数组大小就是 `cap`

![image-20260101122939651](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260101122939651.png)

左开右闭 所以我们切的时候就是指针指向底层的哪个

## 切片不可以比较

不可以通过`==` 比较大小

## 切片生成内存

当执行下面内容的时候 没有生成内存：

```
var a []int
```

所以我们需要初始化

```
var a []int{}
```



# 切片的遍历

因为是数组 所以依旧可以依据 `for`和`range`

# 切片添加元素

`append`格式：

```
b := append(切片,要加入的内容)
```

当`append` 超过`cap`后

一次追加多个元素：

```
b := append(slice,1,2,3,4,5)
```

这样就会把 `12345` 写入`slice`中

切片追加进入切片：

```
b := append(slice,slice2...)
```

我们通过 `...` 就可以自动把 `slice2`的元素拿出 追加进 `slice`中

# 复制切片

我们 通过 `copy`方法 可以复制一个新的切片

格式：

```
copy(a,b) 
```

把a复制到b中

如果不复制 那么指向的是一个底层数组：

```
a := int{1,2,3,4,5}
b := make([]int,5)
c := b
copy(a,b)
b[0] = 100
fmt.Println(a)
fmt.Println(b)
fmt.Println(c)
```

输出：

```
[1,2,3,4,5]
[100,2,3,4,5]
[100,2,3,4,5]
```

原理就是 `c := b`的时候 其实指向的是一个数组

# 删除切片元素

通过切片方法删除：

```
var a int{1,2,3,4,5}
append(a[:index],[index+1]...)
```

我们把 先切出 我开始到 我们要删除的 index 左开右闭 然后选 index+1到最后 写入切片