PE文件格式就是 `exe` `dll【Win32的API 也就是动态链接库】` `sys【内核驱动文件】`等的代称

我们需要执行文件 那么就起码你是需要一个 PE文件

# `CreatePrcoess`

这个就是打开一个进程 也就是让` PE` 上处理机处理的

成功返回非0,失败返回0

参数如下

https://msdn.microsoft.com/query/dev16.query?appId=Dev16IDEF1&l=ZH-CN&k=k(PROCESSTHREADSAPI%2FCreateProcess);k(CreateProcess);k(DevLang-C%2B%2B);k(TargetOS-Windows)&rd=true

```C++
#include <Windows.h>
#include <stdio.h>

//D:\\Notepad++\\notepad++.exe 
int main()
{
	STARTUPINFO st = { 0 };
	PROCESS_INFORMATION pi = { 0 };
	LPCWSTR path = TEXT("D:\\Notepad++\\notepad++.exe");
	int OK = CreateProcess(
			path,
			NULL,
			NULL,
			NULL,
			FALSE,
			CREATE_NEW_CONSOLE,
			NULL,
			NULL,
			&st,
			&pi
		);
	if (OK != 0) {
		printf("调用成功\n 进程ID为：%d", pi.dwProcessId);
		
	}
	else {
		DWORD  err = GetLastError();
		printf("ERROR %d", err);
	}

	return 0;
}
```

其中 最后一个参数`PROCESS_INFORMATION` 是构建完毕后的信息

```c++
PROCESS_INFORMATION STRUCT

hProcess    DWORD     ;进程句柄
hThread     DWORD     ;进程主线程句柄
dwProcessId DWORD     ;进程ID
dwThreadId  DWORD     ;进程的主线程ID

PROCESS_INFORMATION ENDS
```

![image-20260206224459108](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260206224459108.png)

如果这里发现不一样 那么说明 你的 `exe `存在一个 傀儡进程 通过傀儡进程拉取的

# 命令行启动

如果我们通过命令行启动 那么下面方法也是正确的

```c++
#include <Windows.h>
#include <stdio.h>

//D:\\Notepad++\\notepad++.exe 
int main()
{
	STARTUPINFO st = { 0 };
	PROCESS_INFORMATION pi = { 0 };
	WCHAR szcmd[] = L"notepad.exe \"123.txt\"";
	int OK = CreateProcess(
			NULL,
			szcmd, //通过命令行启动
			NULL,
			NULL,
			FALSE,
			CREATE_NEW_CONSOLE,
			NULL,
			NULL,
			&st,
			&pi
		);
	if (OK != 0) {
		printf("调用成功\n 进程ID为：%d", pi.dwProcessId);
		
	}
	else {
		DWORD  err = GetLastError();
		printf("ERROR %d", err);
	}

	return 0;
}
```

# 进程启动的执行过程

1. 我们通过双击 或者命令行 启动文件 那么就 会 启动一个程序 背后本质上`CreateProcess` 或者 `ShellExecute`

2. 通过上述方法构建的时候 那么会对进程初始化 和分配PID 构建进程对象
3. 维护进程 并且分配资源
4. 构建进程的主线程 并且指向程序的入口点
5. 加载到内存  并且上处理机
6. OS需要加载他依赖的DLL
7. 执行结束 删除结构体 退出

大概流程就是上述所说的