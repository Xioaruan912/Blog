这里还没有什么算法 单纯逆向扣代码

# 实战

https://passport.fang.com/?backurl=https%3A%2F%2Fnt.fang.com%2F

我们过一遍他的请求加密解密过程

随便写 没有debugger

![image-20260110161222197](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260110161222197.png)

可以发现有一个数据包为

![image-20260110161251421](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260110161251421.png)

看看他的载荷

![image-20260110161315064](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260110161315064.png)

直接搜索pwd: （要加冒号）

![image-20260110161510709](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260110161510709.png)

直接就找到加密地点了

![image-20260110162031731](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260110162031731.png)

跟入 下断点

可以发现时一个RSA算法

可以发现 传入后一个是 我们的密码 前一个是 

`key_to_encode`

我们全局搜一下

![image-20260110162245582](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260110162245582.png)

下面我们去找找看

`RSAKeyPair`

然后我们把目前找到的内容全部复制到本地

```js


var key_to_encode = new RSAKeyPair("010001", "", "978C0A92D2173439707498F0944AA476B1B62595877DD6FA87F6E2AC6DCB3D0BF0B82857439C99B5091192BC134889DFF60C562EC54EFBA4FF2F9D55ADBCCEA4A2FBA80CB398ED501280A007C83AF30C3D1A142D6133C63012B90AB26AC60C898FB66EDC3192C3EC4FF66925A64003B72496099F4F09A9FB72A2CF9E4D770C41");

function encryptedString(n, t) {
    var e, o, s, h, c, i, f, u, v, l, y;
    if (n.chunkSize > n.digitSize - 11)
        return "Error";
    for (var a = [], p = t.length, r = 0; r < p;)
        a[r] = t.charCodeAt(r),
            r++;
    for (e = a.length,
        o = "",
        r = 0; r < e; r += n.chunkSize) {
        for (c = new BigInt,
            s = 0,
            f = r + n.chunkSize > e ? e % n.chunkSize : n.chunkSize,
            u = [],
            i = 0; i < f; i++)
            u[i] = a[r + f - 1 - i];
        for (u[f] = 0,
            v = Math.max(8, n.digitSize - 3 - f),
            i = 0; i < v; i++)
            u[f + 1 + i] = Math.floor(Math.random() * 254) + 1;
        for (u[n.digitSize - 2] = 2,
            u[n.digitSize - 1] = 0,
            h = 0; h < n.digitSize; ++s)
            c.digits[s] = u[h++],
                c.digits[s] += u[h++] << 8;
        l = n.barrett.powMod(c, n.e);
        y = n.radix == 16 ? biToHex(l) : biToString(l, n.radix);
        o += y + " "
    }
    return o.substring(0, o.length - 1)
}



var pwd = encryptedString(key_to_encode, 'admin');
console.log(pwd);
```

开始F5 然后一直找缺失的函数即可

全部代码拿下来看看 密文

![image-20260110163002908](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260110163002908.png)

可以发现成功了 这样加密算法结束