# GO的学习环境

https://pkg.go.dev/std

https://studygolang.com/

https://studygolang.com/pkgdoc

**对于标准库 学习的越多越好 了解的越多越好**

# 了解GO安装了什么

```
C:\Users\用户\go
```

如果是默认的 可以看到下面情况

![image-20251118200920229](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251118200920229.png)

```
bin 生成编译成功的软件 exe
pkg 生成成功的 包文件
```

我们一般情况下 是每个GO项目都有下面内容

![image-20251118201020222](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251118201020222.png)

# HelloWorld

```
package main

import "fmt"

func main() {
	fmt.Println("Hello world")
}

```

通过

`go build hello.go` 然后执行 exe 即可输出

![image-20251118201339027](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251118201339027.png)

# 分析helloWorld 程序

```
package main // 声明一个main包 要求项目从这里开始执行

import "fmt"  // IO 内置包 

func main() { // 主函数代码块
	fmt.Println("Hello world")
}

```

包： 一个目录下的同文件 都是属于一个包 也就是属于一个类型的包

import： import导入外包

# 命令行

`go build`:编译exe 在没有go 环境中 依旧可以运行

`go run` : 执行 但是不生产 exe 要求在环境中有go

![image-20251118201647903](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251118201647903.png)

# IDE快捷键

![image-20251118201915007](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251118201915007.png)

# main函数和init函数

```go
package main

import "fmt"

func init() {
	fmt.Println("init ____ Hello world")
}

func main() {
	fmt.Println("Hello world")
}

```

```
PS C:\Users\12455\Desktop\GO> go build -o 1.exe .\main.go
PS C:\Users\12455\Desktop\GO> ./1
init ____ Hello world
Hello world
PS C:\Users\12455\Desktop\GO> 
```

可以发现 init 执行在 main前 所以init 一般用于初始化 main用于调用函数 

**一个文件中有多个init 并且可以自上而下执行**

**init函数不可以被调用 并且是自动执行**

**main与init 没有任何参数和返回值**

# 通过GO执行win 命令

```go
package main

import (
	"os/exec"
)

func main() {
	cmd := exec.Command("notepad")
	cmd.Run()
}

```

通过内置包` os/exce` 可以执行命令

如果需要通过 命令返回结果

## 返回win 命令结果

```go
package main

import (
	"fmt"
	"os/exec"
)

func main() {
	cmd := exec.Command("whoam1")       //执行 whoam1 这个cmd命令
	output, err := cmd.CombinedOutput() // 返回 输出 和错误信息（如果有）
	if err != nil {                     // 如果错误信息 存在的话
		fmt.Println("NO 命令错误") // 输出no
	}
	fmt.Println(string(output))
	cmd.Run()
}

```

通过上面的解读 我们可以知道 函数需要返回一个 err 信息 用于分析 如果我们不需要 那么 通过 `_` 即可不取回err

## 添加参数

```go
package main

import (
	"fmt"
	"os/exec"
)

func main() {
	cmd := exec.Command("go", "version") //执行 go 命令 带上参数
	output, err := cmd.CombinedOutput()  // 返回 输出 和错误信息（如果有）
	if err != nil {                      // 如果错误信息 存在的话
		fmt.Println("NO 命令错误") // 输出no
	}
	fmt.Println(string(output))
	cmd.Run()
}

```

# 通过命令行接受系统参数

```go
package main

import (
	"fmt"
	"os"
	"os/exec"
)

func main() {

	cmd := exec.Command(os.Args[1], os.Args[2]) //通过命令行执行 exe的时候 需要添加参数
	output, err := cmd.CombinedOutput()         // 返回 输出 和错误信息（如果有）
	if err != nil {                             // 如果错误信息 存在的话
		fmt.Println("NO 命令错误") // 输出no
	}
	fmt.Println(string(output))
	cmd.Run()
}

```

```
PS C:\Users\12455\Desktop\GO> go run .\main.go go version      
go version go1.24.5 windows/amd64
```

这样就是脚本小子 快速 的构建exe

# 通过命令行获取参数数组

```go
package main

import "os"

func main() {
	for i := 0; i < len(os.Args); i++ {
		println(os.Args[i])
	}
}

```

```
PS C:\Users\12455\Desktop\GO> go run .\main.go go version
C:\Users\12455\AppData\Local\Temp\go-build3170717876\b001\exe\main.exe
go
version
PS C:\Users\12455\Desktop\GO> 
```

输出用户所有的命令内容

# GO项目管理

不基于 GOPATH 而是可以在任意文件夹中 执行go代码



# Golang测试

我们希望测试文件 就通过 测试操作实现

首先我们在函数中添加一个 Add

```go
package main

import "fmt"

func Add(A int, B int) int {
	return A + B + 1
}

func main() {
	//Add(1, 2)
	fmt.Println("Hello World")
}

```

创建一个gotest 函数

```go
package main

import "testing"

func TestAdd(t *testing.T) {
	r := Add(1, 2)
	if r != 3 {
		t.Error(r)
	}
}

```

通过 go test函数 就可以快速测试 代码的功能

![Capturer_2025-11-18_210922_480](https://raw.githubusercontent.com/Xioaruan912/pic/main/Capturer_2025-11-18_210922_480.gif)

# Go的断点调试

![image-20251118211601847](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251118211601847.png)

IDE中对左侧 点击 就可以打断点这样 执行过程中 就会中断

![image-20251118211735936](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251118211735936.png)

可以继续分析函数内容

# Go的编译过程

如果把go 从 .go 转化为 exe

```
go build ./main.go
```

```
 go tool compile -S ./main.go
```

# GO的依赖管理

我们通过Go module 构建依赖

```
set GO111MODULE=auto
go env -w GOPROXY=https://goproxy.cn,direct
```

```
go mod init main
```

通过 go get 就可以获取到 依赖

![image-20251118212721284](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251118212721284.png)

# GO的转义字符

```
\n 换行
\t 制表
\" 输出双引号
\r 
\\
```