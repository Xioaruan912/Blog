# 寄存器

存储临时数据和计算过程的内容

计算机存储体系如图所示：

![image-20260121223740720](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260121223740720.png)

# 8086寄存器

架构如图所示

![image-20260121223841323](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260121223841323.png)

`SP` 用于指向 堆栈顶部

`SI` `DI `用于 间接寻址的 时候的 源和目的地址

## 段寄存器 实模式

段寄存器 会在 实模式和 保护模式下 具有不同的使用方法

我们先看看CPU 如何寻址 下面就是实模式

![image-20260121224146283](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260121224146283.png)

`AD` (`address`和 `data`) 有`20`个 

表示 `2^20  = 1MB` 数据

当时的 `PC寄存器`和`通用寄存器` 只有 `16位` 无法存储完全的地址 `2^16 = 64KB `所以无法寻址这么多

这个时候 就需要 段寄存器出现了

![image-20260121224450491](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260121224450491.png)

`PC`可以查找 `64KB` 所以一个代码段 `64KB` 地址为 `CS` + `PC` 

8086中包含下述寄存器

![image-20260121224612653](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260121224612653.png)

所以 实模式下的寻址 = `CS内部基地址` + `偏移量`

所以我们看到有存储数据是

```
CS:IP 取指令
DS:BX 取数据
SS:SP 取堆栈
```

有下述弊端

1. 最大寻址 1MB 太小了
2. 多进程之间的 隔离不够
3. 缺乏权限控制 应用程序可以访问内核

