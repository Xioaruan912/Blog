![image-20260215235338729](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260215235338729.png)

```
欢迎来到DUTCTF呦
这是一道很可爱很简单的逆向题呦
输入flag吧:123
flag不太对呦，再试试呗，加油呦
请按任意键继续. . .
```

# IDA分析

```c
int __cdecl main(int argc, const char **argv, const char **envp)
{
  int v3; // eax
  __m128i v5; // [esp+0h] [ebp-44h] BYREF
  int v6; // [esp+1Ch] [ebp-28h]
  char v7[32]; // [esp+20h] [ebp-24h] BYREF

  v5 = _mm_loadu_si128((const __m128i *)&key);
  LOWORD(v6) = 0;
  printf(&byte_413E4C, v5.m128i_i64[0], v5.m128i_i64[1], 1129600324, 8210004, 0, v6);
  printf(&byte_413E60);
  printf(&byte_413E80);
  scanf("%s", v7);
  v3 = strcmp(v5.m128i_i8, v7);
  if ( v3 )
    v3 = v3 < 0 ? -1 : 1;
  if ( v3 )
    printf(aFlag);
  else
    printf(aFlagGet);
  system("pause");
  return 0;
}
```

就是一个很简单的 字符串比较

```
strcmp(v5.m128i_i8, v7)
```

并且输出内容就是

```
    printf(aFlag);
```

所以关键的内容就是`key`

```
.rdata:00413E34 key             xmmword '0tem0c1eW{FTCTUD' 
```

小端序 反转一下即可得到字符串 也可以直接通过动调 直接获取

```
"DUTCTF{We1c0met0DUTCTF}"
```

注意上面的内容

**__m128i** 这个数据类型是个啥玩意, 它比较特别, 是一个联合体(union)

 把它当成一个非常灵活的整数型变量就可以了。

`_mm_loadu_si128`函数是直接加载128位值