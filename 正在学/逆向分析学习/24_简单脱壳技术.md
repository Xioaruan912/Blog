也就是去除壳

我们知道加壳的内容在系统中存在解密解压缩的内容 然后恢复原本的代码 这个节点就是我们修改的地方

主要步骤

1. 寻找真正OEP
2. DUMP到磁盘中
3. 修复文件

下面对` UPX`进行操作  当然 `ASPack` 

这里为了方便 我们先关闭地址随机化 如果没有关闭 也可以通过下述方法 实现修改

https://bbs.kanxue.com/thread-259451.htm

开启了ASLR的程序会多一个` .reloc` 节

我们其实可以通过 修改PE文件 从而关闭 地址随机化

![image-20260211214115654](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211214115654.png)

我们先写一个简单的`MessageBox`

```c
#include <Windows.h>

int  main() {
	MessageBox(NULL, TEXT("NI"), TEXT("HAO"), MB_OK);
	return 0;
}
```

我们加壳后直接查壳

![image-20260211212239620](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211212239620.png)

可用发现是 UPX打包的 

# ESP定律

也就是堆栈平衡定律 很多加壳 都是首先通过 

```
pushad
```

保存寄存器 然后通过

```
popad
```

还原寄存器 那么我们可以定位到修改 栈的地方 从而实现定位

我们首先打开`Ollydbg`

![image-20260211212350512](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211212350512.png)

单步执行这个代码 然后对ESP 进行硬件断点

![Capturer_2026-02-11_212439_481](https://raw.githubusercontent.com/Xioaruan912/pic/main/Capturer_2026-02-11_212439_481.gif)

在ESP再次访问这个地址的时候 就会触发中断 如果都执行这个了 说明快恢复了

![image-20260211212536128](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211212536128.png)

然后我们`F9` 自动执行

最后绕过一个循环  直接对最下面的 `JMP` 按下 `F4` 单步就进入了 `.text`

![image-20260211212654075](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211212654075.png)

下面就需要dump出 我们可以直接通过` ollydbg`的插件实现

![Capturer_2026-02-11_214204_637](https://raw.githubusercontent.com/Xioaruan912/pic/main/Capturer_2026-02-11_214204_637.gif)

# 二次断点法

这个不是所有壳都适用的 如果遇见 `telock` 可以使用

原理就是 在我们通过 `module` 对后面的节下`F2`断点 

如果执行 说明 `.text` 一定被解密了 那么我们重新对 `.text` 进行 `F2`断点 执行过程就会断住

从而实现 解密

# SFX自解码

我们可以通过SFX功能 自动分析可能的入口 这里`ollydbg`也自带

![Capturer_2026-02-11_214618_605](https://raw.githubusercontent.com/Xioaruan912/pic/main/Capturer_2026-02-11_214618_605.gif)

这样 OD 会自动分析 找到可能的入口

![image-20260211214812598](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211214812598.png)

# 最后一次异常法

许多壳为了混淆 那么会在不断输出报错信息 这也给我们了可用之际

我们可用通过找到最后一次报错 从而定位 OEP

也可以断点 Win32API函数 从而实现 定位

# OEP附近函数断点

有编译器在OEP附近会执行特殊的函数 例如早期VC++

![image-20260211215054795](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211215054795.png)

我们只需要断点住` GetVersion`函数 那么就可以得到OEP了

# 跨段指令找OEP

许多壳和节是分开的 一般都是需要一个 `JMP `或者`call `去跨段调用 我们如果可用定位到 跨段的指令 那么就可以定位 主要有

`Aspack` `Upx` `Nspack` 这类壳