# base64

常见的 编码和解码

我们下面通过GO实现一个 base64的算法

```go
package main

import (
	"encoding/base64"
	"fmt"
)

func Base64Encoding(src1 string) string {
	src := []byte(src1) //在加密函数内部直接转化格式
	res := base64.StdEncoding.EncodeToString(src)
	return res
}

func Base64Decoding(src string) string {
	res, err := base64.StdEncoding.DecodeString(src)
	if err != nil {
		fmt.Errorf("%s", err)
	}
	rus := string(res)
	return rus
}

func main() {
	var i = "asbdasd"
	fmt.Println("加密执行中")
	encode := Base64Encoding(i)
	fmt.Println("加密结果：", encode)
	fmt.Println("解密执行中")
	fmt.Println("解密结果：", Base64Decoding(encode))
}

```

# 加密原理

1. 字符串转化为二进制格式 也就是转化为 ACSII对应的二进制
2. 6位一组分组 如果最后一组 不足 6位 那么用0 补
3. 每一组转化为ASCII 也就是回归到 字符串
4. 加密结果需要 4个字符一组 如果不足4个字符 那么就填充= 满足

我们直接去查看Go源代码了解一下加密原理

首先进入 `EncodeToString` 函数内部看看

```go
func (enc *Encoding) EncodeToString(src []byte) string {
	buf := make([]byte, enc.EncodedLen(len(src)))
	enc.Encode(buf, src)
	return string(buf)
}
```

可以发现 大概流程就是 构建一个` buf `缓冲区 然后加密写入 缓冲区返回 `	enc.Encode(buf, src)` 是关键代码 进入查看

```go
func (enc *Encoding) Encode(dst, src []byte) {
    //如果传入的是 空 那么直接返回
	if len(src) == 0 {
		return
	}
	//否则初始化一下 结构体
	_ = enc.encode
	//每3字节一组 
	di, si := 0, 0
	n := (len(src) / 3) * 3
    //对每一组进行操作
	for si < n {
		val := uint(src[si+0])<<16 | uint(src[si+1])<<8 | uint(src[si+2])

		dst[di+0] = enc.encode[val>>18&0x3F]
		dst[di+1] = enc.encode[val>>12&0x3F]
		dst[di+2] = enc.encode[val>>6&0x3F]
		dst[di+3] = enc.encode[val&0x3F]

		si += 3
		di += 4
	}

	remain := len(src) - si
	if remain == 0 {
		return
	}
	// Add the remaining small block
	val := uint(src[si+0]) << 16
	if remain == 2 {
		val |= uint(src[si+1]) << 8
	}

	dst[di+0] = enc.encode[val>>18&0x3F]
	dst[di+1] = enc.encode[val>>12&0x3F]

	switch remain {
	case 2:
		dst[di+2] = enc.encode[val>>6&0x3F]
		if enc.padChar != NoPadding {
			dst[di+3] = byte(enc.padChar)
		}
	case 1:
		if enc.padChar != NoPadding {
			dst[di+2] = byte(enc.padChar)
			dst[di+3] = byte(enc.padChar)
		}
	}
}
```

