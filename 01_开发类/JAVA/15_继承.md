# 继承

java 面向对象 主要有3个内容

`封装` ： 把一个对象的多个属性 通过 类 封装起来 从而通过类调用 

`继承` ：当我们书写的javabean类的时候 会出现多个重复数据

![image-20260130145448102](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260130145448102.png)

那么我们可以写一个基本类 其他类去 继承这个基本类即可

![image-20260130145525611](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260130145525611.png)

继承就是类与类之间的父子关系`extends` 通过关键字 构建联系

## 最基础的继承

```java
package src;

public class Person {
    private String name;
    private int age;

    public void Eat(){
        System.out.println("吃饭");
    }
}

```

```java
package src;

public class Student extends  Person {
    int grade;

    public void Study(){
        System.out.println("学习");
    }
}
```

我们可以在父类的基础上 添加新的方法从而 扩大子类

![image-20260130150117505](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260130150117505.png)

```java
package src;

public class Main{
    static void main(String[] args) {
        Student st = new Student();
        st.Study();
        st.Eat();
    }

}
```

## 设计一个复杂的多态

![image-20260130151112588](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260130151112588.png)

1. 类与类之间存在 相同 内容 并且满足 子类是父类的一种 那么就可以通过 继承设计
2. 父类要代表所有的子类 `【人- > 老师|学生】`

![image-20260130151705898](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260130151705898.png)

## 继承的特点

1. 只支持单继承 一个子类只可以继承一个父类
2. 不可以继承多个 父类 但是可以多层继承 就如上图
3. 最大的头和祖宗就是 `object类`

## super

super是遇见多个 变量相同的访问过程

```java
package src;

public class Person {
    String name = "人";
    int age; 

    public void Eat(){
        System.out.println("吃饭");
    }
}

```

```java
package src;

public class Person {
    String name = "人";
    int age; 

    public void Eat(){
        System.out.println("吃饭");
    }
}

public class Student extends  Person {
    int grade;
	String name = "张三";
    public void Study(){
        name = "李四"
        System.out.println("学习"+name); //"李四"
        System.out.println("学习"+this.name); //"张三"
        System.out.println("学习"+super.name); //"人"
    }
}
```

super会去父类找到 `name`是什么 并且最多 只可以访问到 父类 而无法访问 爷爷类

## 成员方法

多个子类共性的方法 抽离到父类 并且 具有就近原则 和 成员一样 可以通过` super`调用 同样没有 爷爷辈

### 方法的重写

通过对父类的方法重写 从而达到更新 由于父类一般是最基本的方法 如果无法满足子类的要求了 就通过这个实现

1. 方法的名字需要相同
2. 方法的声明方法需要相同
3. 参数列表需要保证完全一致

```java
package src;

class FirstPhone {
    public void Call(){
        System.out.println("打电话");
    }
}


class SecondPhone extends  FirstPhone{
    public void Mail(){
        System.out.println("发短信");
    }
}

public class ThirdPhone extends SecondPhone{
    public void Call(){
        System.out.println("打电话变为了视频通话");
    }
    public void Game(){
        System.out.println("玩游戏");
    }
}
```

可以发现 上面的 第三代 我们重写了 `FirstPhone` 的方法

```java
package src;

public class Main{
    static void main(String[] args) {
        ThirdPhone phone = new ThirdPhone();
        phone.Call();
        phone.Mail();
        phone.Game();
    }

}

```

输出如下：

```
打电话变为了视频通话
发短信
玩游戏
```

这就是继承方法的重写 通过快捷键 `Alt + Inset ` 可以快速重写

## 构造方法

父类的构造方法 无法通过 子类继承 只可以 通过 `super` 调用

```java
package src;

class FirstPhone {
    int time;
    public void Call(){
        System.out.println("打电话");
    }
    public FirstPhone(){
        System.out.println("这里是第一代的 构造方法");
    }
    public FirstPhone(int time){
        this.time = time;
        System.out.println("这里是第一代的 带参数的 构造方法" +  this.time);
    }
}


public class SecondPhone extends  FirstPhone{
    public SecondPhone(){
        super(); // 调用第一代没有 参数的构造方法
    }
    public SecondPhone(int time){
        super(time); // 调用第一代没有 参数的构造方法
    }
}
```

可以发现 我们使用父类的构造方法 需要通过 `super()`调用

```java
package src;

public class Main{
    static void main(String[] args) {
        SecondPhone phone = new SecondPhone();
        SecondPhone phone2 = new SecondPhone(1123);
    }

}


```

如果我们不写 无参构造 那么JVM 会自己写上父类构造
