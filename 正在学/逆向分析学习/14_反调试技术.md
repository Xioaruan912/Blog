我们的逆向 都是通过 调试技术 过程 所以编写代码的人就会写出 反调试技术

也就是对抗

静态：加壳 混淆  从而让逆向代码完全混乱 看不懂

动态：也就是反调试 直接报错 自杀不工作

下面就学习简单的反调试技术

**核心问题**：检测自己是否被调试 或者有没有调试器存在

# `isDebuggerPresent`

这个是win32API

![image-20260202175142655](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260202175142655.png)

最基本的检测调试器 最容易被`hook`

# `PEB->BeingDebugger`

段寄存器 有一个 FS寄存器 指向的是一个 `TEB` 线程控制块 

并且在`线程控制块TEB` 中存在一项` PEB` 指向进程控制块 

在`PEB` 内部有一个`BeingDebugger` 检测是否在`debugger` 如果是 就是1 否则0

这个也是 `isDebuggerPresent` 的执行过程

![image-20260202175544519](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260202175544519.png)

直接读取 可以绕过 上面的 `hook`

# `NtQueryInformationProcess`

这个是属于 windows 底层函数 我们无法直接调用

我们需要手动加载 

```
HMOUDLE hm = LoadLibrary(_T("Ntdll.dll"));
```

![image-20260202180418981](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260202180418981.png)

通过查询结果 就可以知道有没有了

这个查询原理是 在windows 内核中 查询

# `EPROCESS->DebugPort`

![image-20260202180603942](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260202180603942.png)

这就是上述查询过程通过内核驱动 去内核中查询 `debugport` 从而确定是否被调试 这也是许多游戏检测

# 异常处理检测

上述有一些我们可以尝试通过` API hook` 返回错误信息 从而绕过检测

如果存在调试器 那么我们通过 `int 3` 触发后 就会自己发送给调试器 通过这个方法 我们可以检测是否处于调试器中

```c++
#include <windows.h>
#include <stdio.h>

BOOL checkdebugger() {
    __try {
        __asm {
            int 3
        }
        // int3 没触发异常 → 被调试
        printf("【被调试】int3 被调试器截获\n");
        return TRUE;
    }
    __except (EXCEPTION_EXECUTE_HANDLER) {
        // int3 进了 SEH → 没被调试
        printf("【未被调试】int3 被程序捕获\n");
        return FALSE;
    }
}

int main() {
    checkdebugger();
    return 0;
}

```

# 断点检测

我们只需要查看 是否注入` 0xcc`  并且和PE文件检测对比 查看 就可以确定是否处于调试状态了

# 检测调试器进程

检测是否调试器存在 那么就调试 检测调试器列表

![image-20260202182856563](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260202182856563.png)

这会拖累 执行效率

查找 句柄

![image-20260202182922055](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260202182922055.png)

我们可以通过调用` VC++`自带的`SPY++` 确定出 窗口信息

![image-20260202183048187](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260202183048187.png)

背后就是通过` findWindow` 查找到的

![image-20260202183124634](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260202183124634.png)

# 时间检测

如果执行时间 莫名其妙变为 10s 那么就可以通过这个方法进行判断

```
    __asm
    {
        rdtsc           // 调用时钟
        xor ecx, ecx
        add ecx, eax    // 将eax与ecx相加
        rdtsc           // 再次调用时钟
        sub eax, ecx    // 两次结果做差值
        mov Debug, eax
    }
```

