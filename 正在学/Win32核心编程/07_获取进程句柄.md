我们之前一致都有 和 句柄参与 在`CreateProcess` 中 最后传入的一个结构体 是 `PROCESS_INFORMATION` 的指针 里面包含 `handle` 也就是句柄

```c
typedef struct _PROCESS_INFORMATION {
    HANDLE hProcess; //进程句柄
    HANDLE hThread; //主线程的句柄
    DWORD dwProcessId; 
    DWORD dwThreadId;
} PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;
```

# 打开进程

我们这 是打开一个 已经存在的 进程 从而得到句柄 `OpenProcess`

 需要是一个 已经存在的进程

![image-20260219154446701](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260219154446701.png)

第一个是访问权限 我们通过最后一个 传入需要获取的 进程ID

返回值是一个` handle`类型

![image-20260219154824313](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260219154824313.png)

我们去关闭这个 `ACE`

```c
#include <Windows.h>


int main() {
	HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, 38020);
	if (hProcess != NULL) {
		TerminateProcess(hProcess, 2000);
	}
	return 0;
}
```

如果我们需要关闭 火绒等 这代码是无法进行的

可以发现 不一定所有进程都可以 得到句柄 并且操作 需要从内核方面实现