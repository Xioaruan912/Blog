Go语言 支持 

1. 函数
2. 匿名函数
3. 闭包

```
func 函数名(参数)(返回值){
	函数体
}
```

我们通过` 函数名(）` 调用

# 普通调用

```go
package main


import "fmt"

//不带参数 不带返回值
func hello(){
	fmt.Println("HEllo")
}

//带参数 不带返回值
func bye(x,y int){
	fmt.Println("HEllo,",x,y)
}

//带参数 不带返回值
func you(x string)(string,int){
	fmt.Println("HEllo,",x)
	return x,1
}
func main(){
	hello()
	bye(1,2)
	if i,e := you("1"); i!=string('1') || e !=1{
		fmt.Println("you")
	}
}
```

# 函数接受可变参数

```go
package main

import "fmt"

// 可变参数
func bye(x ...int) int {
	ret := 0
	for _, arg := range x {
		ret = ret + arg
	}
	return ret
}

func main() {
	fmt.Println(bye(1, 2))
}

```

这里说明 GO内部可以接受多个 参数

这个`X `在函数内部是一个`切片`类型 可以通过` for` 循环获取内容

可以混用， 但是 可变参数一定要 在函数后

```go
package main

import "fmt"

// 可变参数 x一定要在 a后面定义 【a一定要传，x不一定要传】
func bye(a int,x ...int) int {
	ret := 0
	for _, arg := range x {
		ret = ret + arg + a
	}
	return ret
}

func main() {
	fmt.Println(bye(1, 2.30,60))
}

```

# defer

go 的 `defer` 语句用于 延迟处理后面跟着的

在`main`函数中 如果有一个` defer 语句 `那么 `defer` 会在 `main`结束之前 最后一个执行

这样可以保证了 文件的关闭 或者 套字节的断开

```go
package main

import "fmt"

func main() {
	fmt.Println("这里是 第 0 个语句")
	defer fmt.Println("这里是 第 1 个语句")
	fmt.Println("这里是 第 2 个语句")

}

```

输出结果：

```
这里是 第 0 个语句
这里是 第 2 个语句
这里是 第 1 个语句
```

这里是通过栈的存储 所以如果我们 3个全部defer 那么就是 `后进先出`

```go
package main

import "fmt"

func main() {
	defer fmt.Println("这里是 第 0 个语句")
	defer fmt.Println("这里是 第 1 个语句")
	defer fmt.Println("这里是 第 2 个语句")

}

```

输出结果：

```
这里是 第 2 个语句
这里是 第 1 个语句
这里是 第 0 个语句
```

# 变量作用域

全局变量：

也就是整个文件内部的函数都可以访问到的变量 在函数外部定义

```go
package main

import "fmt"

var num = 10

func test() {
	fmt.Println(num)
}

func main() {
	test()
}

```

他的生命周期是本代码结束

局部变量：

```go
package main

import "fmt"

var num = 10

//输出结果是100
func test() {
	num := 100
	fmt.Println(num)
}

func main() {
	test()
}

```

`	num := 100`的声明周期 函数结束后就没了 不会带出函数

# 函数可万能

Go中 函数可以 赋值给变量 可以作为返回值 

```go
package main

import "fmt"

var num = 10

func test() {
	fmt.Println(num)
}

func main() {
	// test函数作为变量 给abce
	abce := test
	//那么 我们可以通过 abce 执行
	abce()
}

```

可以作为参数传入函数：

```go
package main

import "fmt"

var num = 10

func add(x, y int) int {
	return x + y
}

// op func(int, int) int 传入两个 int 返回一个 int
func calc(x, y int, op func(int, int) int) int {
	return op(x, y)
}

func main() {

	res := calc(1, 2, add)
	fmt.Println(res)
}

```

