

Go 语言的指针 不允许 偏移和运算 所以不会导致安全问题

Go 语言中 指针只有两个运算

`&` ：取地址 返回的是一个地址 `&a` 就是返回`a` 变量的地址

`*` ：根据地址取值 我们获取地址后 可以通过 `*v` 其中`v`是一个地址 访问资源

Go 语言中的传递参数 都是`值拷贝` 如果函数内部要修改外部值 就需要传递指针

# 指针地址和类型

Go语言中的每个变量 都有自己的地址 代表内存中的区域我们 可以通过`&` 获得这个地址 Go中的值类型 都有地址 `(int ,String ,Float ,bool ,array ,struct)`

取变量地址格式：

```go
ptr := &a
```

这里给出一个小例子：

```go
package main

import "fmt"

func main() {
	a := 10
	ptr_a := &a //是一个指针 *int类型
	fmt.Println("地址是", ptr_a)
	fmt.Println("通过ptr_a获取值", *ptr_a)
}

```

输出结果：

```
地址是 0xc0001060a8
通过ptr_获取值 10
```

![image-20260116220010303](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260116220010303.png)

​	

```go
package main

import "fmt"

// 接受的是一个地址
func test(a *int) {
	*a = 100
}

func main() {
	a := 10
	ptr_a := &a
	fmt.Println("地址是", ptr_a)
	fmt.Println("通过ptr_a获取值", *ptr_a)
	test(ptr_a)
	fmt.Println("地址是", ptr_a)
	fmt.Println("通过ptr_a获取值", *ptr_a)
}

```

输出结果：

```
地址是 0xc00008c0a8
通过ptr_a获取值 10
地址是 0xc00008c0a8
通过ptr_a获取值 100
```

可以发现 地址是没有变化的 值发生了改变

# new和make

`new`是内置的函数

```
func new(Type) *Type
```

通过`new`函数 得到一个指针 并且返回的是对应 类型的 零值指针

1. 给你初始化了 一个变量 并且赋值为零值
2. 返回给你这个 变量的 指针

`new` 其实使用的不多

`make` 只用于 分配 `slice ,map ,channel `的内存创建 并且返回的是类型本身 而不是 指针

```
func make(Type,...size) Type
```

## 区别

1. `new`是对基本类型 `make`只能对 `slice` `map` 和 `channel` 初始化
2. `new`返回指针 并且初值为零值 `make` 返回类型 初值为零值