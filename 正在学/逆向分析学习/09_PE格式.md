`Win `中 组织二进制的文件格式

常见的有

1. `exe`
2. `dll`
3. `sys`
4. `ocx`
5. `com`

是基于 `Unix`的`COFF`格式发展而来的

![image-20260124172708003](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124172708003.png)

很多时候 逆向分析的开始 就是通过 `PE`文件出发的 下图就是一个 PE文件的构成

![image-20260124172828847](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124172828847.png)

我们按照 `header`和 `section` 分别学习 我们通过` winhex` 打开一个 之前写过的 exe文件

# Header

## DOS头

这里是为了兼容 而留下的设计 早期的win 确保 windows设计 可以在 `dos`系统上执行 所以保留了 `dos头`

1. 定长的 `DOS 头`
2. 不定长的`DOS stub ` 残留部分

![image-20260124173231954](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124173231954.png)

这里 圈出来的 就是 DOS 头 PE的格式头 也就是 `MZ = 4D5A` 这也是我们分析是不是 PE的主要方法

  ![image-20260124173434248](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124173434248.png)

这个字段说明了 `NT头`在 整个 文件中的 `起始地址` 发现是 `E0` 那么 `E0-30` 剩下的 就是 `PE stub` 

![image-20260124173626987](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124173626987.png)

残留段内容就是

1. 通过 调用21号中断的 9号功能
2. 输出一个字符串 `This program cannot be run in DOS mode.`
3. 然后调用 `4C` 退出程序

## NT头

### 24字节信息

这才是PE真正的部分

![image-20260124174813672](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124174813672.png)

前4字节是固定的` 50 45 00 00 ` 表示 `PE`

20字节 包含重要信息

![image-20260124174122456](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124174122456.png)

1. `014C = x86 32 位`  
2. `05 00` → 5 个节  说明这个PE文件有 5个节
3. 编译时间戳 `69 74 2C 69`
4. `COFF 符号表`的偏移为 `00 00 00 00`
5. 符号表项数量 基本废弃
6. 可选头的大小 `00 E0` 虽然是可选头 但是在 PE文件中是必须的
7. 文件属性 `01 0E`

### 可选头

我们上面可以知道 可选头的长度 为 `0xE0` 对于 `exe`和`dll` 是必不可少的 存储PE文件 大量重要信息

![image-20260124174945685](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124174945685.png)

#### `Image_base`

 就是 PE 文件需要加载到 内存的哪个地址上

对于` exe` 一般是 `0x00400000` 对于一个 `dll` 一般是`0x10000000 ` 这两个值只是建议值

现在高版本 都是通过 `ALSR 机制` 也就是 `地址空间加载随机化`技术

每次加载的地址都随机化 从而无法完全定位出

#### `AdreeOfEntryPoint`

PE程序的执行入口地址 并且保存相对地址 真实入口为 `Image_Base + AdressOfEntryPoint`

进程开始运行 就从这个地址进入 对于 `dll` 这个是初始化函数的地址

#### `DllCharacteristics`

和PE头中的一样 具有许多属性 如果PE文件支持安全机制 那么就有 对应 比特位表示

![image-20260124175616901](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124175616901.png)

这样 `OS`在加载本程序的时候 就会应用 安全机制

#### 数据目录

在可选头的最后 有一个大数组

![image-20260124175738042](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124175738042.png)

这就是数据目录

PE文件除了 数据和指令 还有其他内容 例如 

依赖别的共享库的函数等  那么需要一个表登记信息 =`导入表`

如果一个程序 自己需要导出函数给别的用 那么就需要一个 `导出表`

这些重要内容 分别定义在 PE的哪个位置 这就需要通过 数据目录 定位出来

数组的每一项都是 也就是`相对Image_base的相对地址`和`大小`

![image-20260124175951653](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124175951653.png)

现在操作系统 一般存储了 16组信息

![image-20260124180039254](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124180039254.png)

## 节表

PE文件是按照 `节`为 单位 组织各个数据和代码

在正文部分 依次按照`节 `排列

文件头部中 设定了一个 节表 用于 定位 节的位置和信息 固定`40字节`

![image-20260124180228752](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124180228752.png)

其中 地址依旧是 相对于` Image_Base`的相对地址

`VirtualAdress`：节在内存运行中的相对地址

`PointerToRawData`：节在文件的偏移

我们通过两个字段 就可以快速定位到 内存运行和 文件静态中 节的位置

# 总结header

整个头部构成如下

```
1. DOS 头
   1.1 IMAGE_DOS_HEADER
   1.2 DOS Stub

2. NT 头
   2.1 PE Signature  （50 45 00 00） 
   2.2 File Header（基本信息）
   2.3 Optional Header（可选头）
       2.3.1 标准字段
       2.3.2 Windows 专用字段
       2.3.3 Data Directories（数据目录）

3. Section Table（节表）
```

1. `DOS 头` 是由于兼容 以前机器
2. `NT`头为主要内容 存储 信息和 可选头 是`PE 的核心`
3. `节表`用于 定位 排列的数据和代码

在学习Sections的前面我们先学习 

# PE 如何导入内存运行

由于页面对齐 起始导入内存后 PE文件会扩大

![image-20260124195058142](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124195058142.png)

通过`可选头`中的

`FileAlignmant`：原始PE文件中各个部分的对齐大小 默认是硬盘扇区大小 512字节 头部和节都需要按照这个大小对齐 如果小于那么通过`00`填充 所有节的开始地址一定是` 0x200` 的整数倍

`SectionAlignmant`：文件被加载到内存后 各个部分的 对齐数值 默认是一个页面大小 `x86`下默认是`4KB= 0x1000` 所以内存中各个部件的起始地址是` 0x1000`的整数倍 

这里有两个地址的描述：

`RVA`：PE文件加载到内存后 相对于 加载后的基地址的 偏移量 也就是 全部都是在内存中的

`FOA`：静态PE文件的某个地址 相对于 基地址的 偏移量 是没有进入内存的

如果PE文件加载到内存中 `FileAlignmant` 和 `SectionAlignmant` 的对齐一样 那么 `RVA`和`FOA`值相同 但是现实都是不同的 也就出现下图

![image-20260124200304191](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124200304191.png)

我们无法通过 线性计算获取每个节的地址 因为无法估计 节的大小

所以 我们通过 `节表` 记录所有节的信息 从而到达 寻找

# Sections

这里是节区 主要就是 不同节的 排布 从而组合成 整个 PE文件

我们逆向分析过程中 可能会遇见 恶意软件 修改 导入导出表 从而实现代码 注入 或者 劫持执行流程

我们需要通过导入导出表 从而分析代码执行过程

在头部分析过程中 有一个 节表 通过对节表的遍历 就可以得到整个PE文件的构成

主要有下述节：

`.text`：代码节（VC）

`.code`：代码节（VB）

`.data`：数据节（存放的是 已经初始化的全局变量和 静态变量）

`.rdata`：只读数据节（存放 常量字符串 虚表等）

`.idata`：输入数据节 （存放 IAT 和 导入表）

`.bss`：存放未初始化的 全局变量和静态变量

`.textbss`：代码和未初始化的 全局变量和静态变量

`.rsrc`：资源节

`.reloc`：重定位表

## 导入表

我们在编程开发的时候 需要导入其他库函数

```
#include <stiod.h>
```

通过 `静态库`和 `动态库`的方法导入

`静态库` 通过编译 链接后 库就结合进入程序本身了 变为 一个 PE 文件

`动态库` 通过`动态链接`的方法 被程序调用

1. 动态库需要对外声明 自己有什么函数可以被外界调用 名字和地址是什么 这就是`导出表`
2. 使用者 需要声明 自己依赖于什么库 这就是`导入表`

如果查找不到 导入表的函数 就会发生 报错

![image-20260124200948329](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124200948329.png)

我们可以通过 `数据目录[1] `访问到 导入表：

![image-20260125230714466](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125230714466.png)

导入表结构 如下：

![image-20260124201732790](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124201732790.png)



 每一个 导入描述符 描述了一个` DLL` 的信息 20字节 内容如下：

![image-20260124203023672](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124203023672.png)

`导入表如何确定结束了`：有多少个外部 动态链接库的引入 这里就有多少项 我们分析导入表结束 只要导入表的 `Name`字段 为0 就代表没有下一个导入表了

### `OriginalFirstThunk`

是一个`指针 `是一个`RVA `指向一个` INT表（导入名字表）`表项内容如下：

![image-20260125230956991](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125230956991.png)

他是一个指针 指向

### `Hint表/Name表`

 包含导出函数名字和导处表的索引

![image-20260125231039559](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125231039559.png)

### `name`

保存一个指针 指向导入链接库的名字

![image-20260125231214414](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125231214414.png)

通过这两个字段我们可以得到 一个索引 一个动态库的名字 但是依旧无法调用 因为不知道地址在哪里 所以我们需要一个`导入地址表IAT`

###  `FirstThunk `

为了把 导入表和 导入地址表结合起来我们通过 `FirstThunk `字段确定

一个`指针` 指向 `IAT` 

## 导入地址表 IAT

![image-20260125231336767](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125231336767.png)

这个表内部都是一堆地址 都是动态库的各个函数具体地址

不同动态库之间用 `4字节的00`区分

`IAT`的每个表项和`INT`的每个表项 一一对应

`在DLL没有加载到内存的时候` IAT表和INT都指向的是 名字和索引表

只有 DLL 加载到内存中 IAT 才保存 动态链接库函数的地址

PE文件开始加载 OS开始遍历导入表 依次加载 依赖的动态函数库 并且通过 `GetProcessAdress` 函数 获取 INT 指向的函数的地址 并且填入 IAT



这里就是一个PE文件使用外部函数 需要通过 导入表 找到函数名字和索引 从而获取地址的原理与过程

## 导出表

我们可以在数据目录的第9项定位到 自己PE的导出表

这里是 作为一个 DLL 动态链接库 我们需要登记信息 从而让外部调用 这就需要导出表

![image-20260125232101590](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125232101590.png)

### `Base`

编号导出函数的话就从 base开始

### `name`

和导入表一样 是一个指针 指向本动态链接库名字 按照`\0`结尾 

### `NumberOfFuntions`

记录当前 PE文件 导出函数的总个数

### `NumberOfNames`

当前PE 按照`名字 导出` 的函数个数

因为PE文件可以通过 `函数编号 导出` 也可以通过`名字导出`

### `AdressOfFunctions`

一个指针 指向 `导出地址表 EAT` 里面存放的是 所有导出函数的地址

![image-20260125232444028](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125232444028.png)

### `AdressOfName`

指针 指向的是 以名字导出函数的 `导出名字地址表 ENT`

### `AdressOfNameOrdinals`

指针 指向的用于 `导出名字地址表 ENT` 获取对应 `EAT` 的地址 的一个表

![image-20260125232644517](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125232644517.png)

通过这个可以快速 通过名字 找到 导出函数地址表中的表项

# 实战分析

我们通过VC++ 构建一个 我们之前学过的 多态

```c
#include <stdio.h>
class OSbase{
public: //基本类中 定义出一个虚函数 并且是纯虚函数
	virtual int create_process() = 0 ;
};


//用 win32OS类 继承 基本类
class Win32OS : public OSbase{
public:
	//实现 虚函数的内容
	virtual int create_process(){
		printf("enter Win32\n");
		return 0;
	}
};

//定义一个宏 用于分析是不是win32
OSbase* CheckOS(){
#ifdef WIN32
	return new Win32OS;
#endif
}

int main(){
	//通过宏 分析是不是 win32 如果是 就返回Win32OS类
	OSbase* os = CheckOS();
	//通过Win32OS 类 执行虚函数
	os->create_process();
	return 0;
}
```

通过` winhex` 打开分析

## DOS头

![image-20260125232951938](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125232951938.png)

可以发现 从 E0 开始 就是 NT头的开始

## NT头

固定4字节 + 20字节信息

![image-20260125233040093](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125233040093.png)

我们可以通过 `SizeOfOptionalHeader` 获得 可选头的大小 倒数 3 4 字节 `00 E0`

这样我们就确定了可选头

![image-20260125233310779](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125233310779.png)

我们定位到 节表后 向前 推 `8 * 16 ` 就是数据目录大小 由于1个项占8字节 并且有16项 从而得到

![image-20260125233843064](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125233843064.png)

## 导入表

数据目录的 [1] 第二项 就是导入表地址 `第二个 8字节`

第一个 4字节是地址 第二个4字节是大小 可以发现

地址是 `0002D000` 大小是`0x00000028`

![image-20260125234150025](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125234150025.png)

现在要去定位 哪个节 存储导入表

## 节表

节表的一个表项 40字节 也就是 `两排半`

![image-20260125234423156](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125234423156.png)

我们知道 节表的 `8字节名字` + `DWORD` 后是 RVA  `00001000`

![image-20260125234613624](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125234613624.png)

我们按照这个方法 查找 导入表在哪个节中

最后我们定位到 `.idata节中 `我们之前学习的过程中 也知道 导入表就 是在` idata`中

![image-20260125234907489](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125234907489.png)

但是我们需要知道 RVA 是内存运行后的地址 我们需要找到 文件中地址 这 就需要 节表的 `PointerToRawData` 字段 找到 `.idate`在文件中的地址

![image-20260125235219870](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125235219870.png)

所以 我们可以确定 `FOA = 00 02 B0 00`

现在我们直接定位到 `0002B000`上分析

![image-20260125235403958](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125235403958.png)

这里开始的地方就是导入表的地方

## 导入表继续分析

我们知道 导入表以20字节为一个导入描述符 并且以全0为结束

![image-20260125235548809](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125235548809.png)

也就是说 这个`exe` 只引入一个` DLL`

我们可以开始分析这个动态链接库了

![image-20260124203023672](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124203023672.png)

### name

`00 02 D6 30` 是一个指针 指向字符串 并且 以 `\0` 结尾 是一个 RVA 那么FOA 就是 `0002B630`

![image-20260125235928485](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260125235928485.png)

### OriginalFirstThunk

指向 INT表 换算为 FOA 为 `0002B028`

![image-20260126000225138](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260126000225138.png)

### FirstThunk 

找到指向 IAT表的地址 也就是 最后一个 `DWORD ` `0002D150` 换算FOA `0002B150`

![image-20260126000352289](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260126000352289.png)

我们可以发现 没有运行过程中 两个表的指向地址都是一样的

我们也不需要这么辛苦分析 在数据目录的 第12个表项中 就存放着 IAT表的地址 可以快速定位

### Hint表/Name表

我们知道 INT 内容 指向的是一个 索引名字表 我们去找这个表就 可以得到 导入函数的名字和索引

 一个 2字节的word 一个 char数组

![image-20260126001016213](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260126001016213.png)

# 导出表

我们知道 数据目录的 第0项 就是导出表

![image-20260126002436641](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260126002436641.png)

可以发现这个程序是没有导出表的

# 实际工作

可以发现 这个分析一个 PE文件很辛苦 我们一般都是通过 工具直接定位 例如 `VC++` 安装目录下有一个工具 `E:\Microsoft Visual Studio\Common\Tools\DEPENDS.EXE`

可以快速分析 导入导出表

![image-20260126001755147](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260126001755147.png)

上面红色 是 程序 使用DLL 了多少函数

下面是 DLL 总共导出了多少函数

​	
