# 匿名函数

也就是 不需要函数名字的函数 执行到这里了 直接执行函数

1. 用于回调函数
2. 用于闭包

```go
func main() {
	func() {
		fmt.Println("这里是匿名函数")
	}
}

```

使用方法：

```go
//方法1
func main() {
	//通过 赋值给变量 然后执行
	say := func() {
		fmt.Println("这里是匿名函数")
	}
	say()
}

```

```go
//方法2
func main() {
	//定义  并且 直接执行函数
	func() {
		fmt.Println("这里是匿名函数")
	}()
}
```

# 闭包

也就是一个函数和其使用的环境 组合成的 概念
`闭包 = 函数 + 使用环境`

```go
package main

import "fmt"

// 返回值是函数的返回值
func say() func() {
	name := "Xooo"
	return func() {
		//首先会在函数内部查找 name 没有 那么就跳出函数 看看上层
        //直到找到 全局变量
		fmt.Println("say", name)
	}
}
func main() {
	r := say()
	r()
}

```

这里就说明了 一个闭包 `函数+ 外层变量的引用`

我们要分析是不是 闭包 就看 整个函数 是不是用了外层的 变量 不是自己声明的

# 内置函数

![image-20260116174636601](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260116174636601.png)

# panic/recover错误处理

`panic` 可以在任意地方 引发 报错

`recover`只有在 `defer ` 调用的函数内部引发

```go
//函数会在 最后 收集错误 如果有错误 不是停止项目 而是输出错误
defer func(){
	err := recover()
	if err != nil {
		fmt.Println("error")
	}
}()

//允许下面语句 直接报错 从而被 recover 收集
panic("panic 触发")

```

所以` recover` 可以看作就是收集错误 并且让程序员处理的 这样就不会导致 程序崩溃出错

