主要是分支判断和循环的 汇编语言实现 从而更能清晰的 了解框架

# if else

```c++
#include<stdio.h>


void test(int a){
	if(a == 1){
		printf("success\n");
	}else{
		printf("error\n");
	}
}

int main(){
	test(2);
	return 0;
}
```

上面是一个最简单的 `if else` 语句 我们通过`https://godbolt.org/` 分析

![image-20260122152852577](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122152852577.png)

```
00401020   push        ebp
00401021   mov         ebp,esp
00401023   sub         esp,40h
00401026   push        ebx
00401027   push        esi
00401028   push        edi
00401029   lea         edi,[ebp-40h]
0040102C   mov         ecx,10h
00401031   mov         eax,0CCCCCCCCh
00401036   rep stos    dword ptr [edi]
```

这个是函数执行的时候 自动初始化 自己的栈帧 下面是函数的功能点

```
5:        if(a == 1){
00401038   cmp         dword ptr [ebp+8],1
0040103C   jne         test+2Dh (0040104d)
```

可以发现 通过 `CMP` 比对 `[ebp+8]`和1的值 我们可以去获取到 `ebp+8`是什么 `ebp=0019FED8`+`8` = `0019FEE0`

![image-20260122153530818](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122153530818.png)

发现是2 `jne ` 是如果不等于 就跳转 通过 `ZF标志位` 确定是否跳转

我们看看如果等于 也就是顺序执行 会是什么

```
6:            printf("success\n");
0040103E   push        offset string "success" (00422024)   
00401043   call        printf (004010d0)
00401048   add         esp,4
```

发现 设置字符串 并且` call` 打印

最后的 `esp+4` 是

总结：对于if else的跳转 就是简单的 两个判别 通过 `cmp` 获取 再通过`jmp`指令 如果错误就跳 否则顺序执行

# switch

```C++
#include <stdio.h>



char* test_switch(int status){
	char* msg = NULL;
	switch(status){
	case 200:
		msg = "OK";
		break;
	case 404:
		msg = "Not Found";
		break;

	}
	return msg;
}


int main(){
	test_switch(200);
	return 0;
}
```

我们去查看 汇编代码

```
5:    char* test_switch(int status){
00401020   push        ebp
00401021   mov         ebp,esp
00401023   sub         esp,48h
00401026   push        ebx
00401027   push        esi
00401028   push        edi
00401029   lea         edi,[ebp-48h]
0040102C   mov         ecx,12h
00401031   mov         eax,0CCCCCCCCh
00401036   rep stos    dword ptr [edi]

```

依旧创建栈帧初始化内容

```
6:        char* msg = NULL;
00401038   mov         dword ptr [ebp-4],0
```

设定局部变量 为0 也就是`NULL`

```
7:        switch(status){
0040103F   mov         eax,dword ptr [ebp+8]  //把status变量 存入 eax中
00401042   mov         dword ptr [ebp-8],eax  //把eax 内容写入函数内部的局部变量中
00401045   cmp         dword ptr [ebp-8],0C8h //把局部变量和 0C8h比较也就是 200
0040104C   je          test_switch+39h (00401059)  //如果等于就跳转 否则继续执行 00401059
0040104E   cmp         dword ptr [ebp-8],194h    //比较 404
00401055   je          test_switch+42h (00401062) //如果等于就跳转 00401062
00401057   jmp         test_switch+49h (00401069) //否则无条件跳转 00401069

```

这里是初始化汇编 注释都在上面了

```
8:        case 200:
9:            msg = "OK";
00401059   mov         dword ptr [ebp-4],offset string "OK" (00422028)  //ok写入局部变量中
10:           break;
00401060   jmp         test_switch+49h (00401069)  //跳转00401069
11:       case 404:
12:           msg = "Not Found";
00401062   mov         dword ptr [ebp-4],offset string "Not Found" (0042201c)
13:           break;
14:
15:       }
```

这里就是 赋值了

```
16:       return msg;
00401069   mov         eax,dword ptr [ebp-4] //这里为返回做准备
17:   }

```

# while

```c
void test_while(){
	int a = 100;
	while (a)
	{
		printf("%d",a--);
	}
}
```

初始化栈帧

```
00401080   push        ebp
00401081   mov         ebp,esp
00401083   sub         esp,48h
00401086   push        ebx
00401087   push        esi
00401088   push        edi
00401089   lea         edi,[ebp-48h]
0040108C   mov         ecx,12h
00401091   mov         eax,0CCCCCCCCh
00401096   rep stos    dword ptr [edi]
```

为局部变量赋值 赋值在自己的栈帧中

```
22:       int a = 100;
00401098   mov         dword ptr [ebp-4],64h
```

`while`分析如下

```
23:       while (a)
0040109F   cmp         dword ptr [ebp-4],0
004010A3   je          test_while+47h (004010c7)

```

通过比较 局部变量和 `0`的大小关机 设置 如果等于就跳转 否则顺序执行下面内容

```
24:       {
25:           printf("%d",a--);
004010A5   mov         eax,dword ptr [ebp-4]  
004010A8   mov         dword ptr [ebp-8],eax
004010AB   mov         ecx,dword ptr [ebp-8]
004010AE   push        ecx
004010AF   push        offset string "%d" (0042211c)
004010B4   mov         edx,dword ptr [ebp-4]
004010B7   sub         edx,1
004010BA   mov         dword ptr [ebp-4],edx
004010BD   call        printf (0040d720)
004010C2   add         esp,8
26:       }

```

1. 把局部变量存入 `eax`中
2. 再存入 局部空间中 这里是因为 `mov`的源操作数 不可以都是 `间接寻址` 需要通过寄存器 中转
3. 存入 `ecx`  为函数调用 传递参数
4. 先 `edx`减去1 回写到变量`a`中去
5. 触发函数调用

最后无条件跳转到 `while`中

```
26:       }
004010C5   jmp         test_while+1Fh (0040109f)
27:   }

```

# do while

`do while` 循环会先执行一次 循环体 然后分析是否继续循环

```c
void do_while_test(){
	int a = 10;
	do 
	{
		printf("%d",a--);
	} while (a);
}
```

```
30:   void do_while_test(){
0040D7A0   push        ebp
0040D7A1   mov         ebp,esp
0040D7A3   sub         esp,48h
0040D7A6   push        ebx
0040D7A7   push        esi
0040D7A8   push        edi
0040D7A9   lea         edi,[ebp-48h]
0040D7AC   mov         ecx,12h
0040D7B1   mov         eax,0CCCCCCCCh
0040D7B6   rep stos    dword ptr [edi]

```

初始化 下面是定义一个局部变量 存入 `[ebp-4]`

```
31:       int a = 10;
0040D7B8   mov         dword ptr [ebp-4],0Ah
```

下面 可以发现和我们分析 `while` 一样的执行过程 所以 `do while`在函数体循环内部和 `while` 过程是一样的

```
32:       do
33:       {
34:           printf("%d",a--);
0040D7BF   mov         eax,dword ptr [ebp-4]
0040D7C2   mov         dword ptr [ebp-8],eax
0040D7C5   mov         ecx,dword ptr [ebp-8]
0040D7C8   push        ecx
0040D7C9   push        offset string "%d" (0042211c)
0040D7CE   mov         edx,dword ptr [ebp-4]
0040D7D1   sub         edx,1
0040D7D4   mov         dword ptr [ebp-4],edx
0040D7D7   call        printf (0040d720)
0040D7DC   add         esp,8

```

下面是区别

```
35:       } while (a);
0040D7DF   cmp         dword ptr [ebp-4],0
0040D7E3   jne         do_while_test+1Fh (0040d7bf)
36:   }
```

最后才是比较和 `0` 然后如果不等于就 跳转否则 结束函数

# for

`for` 循环是稍微复杂的内容

```c
void test_for(){
	for(int a=0;a <= 100;a++){
		printf("%d",a);
	}
}
```

初始化栈帧

```
38:   void test_for(){
0040D800   push        ebp
0040D801   mov         ebp,esp
0040D803   sub         esp,44h
0040D806   push        ebx
0040D807   push        esi
0040D808   push        edi
0040D809   lea         edi,[ebp-44h]
0040D80C   mov         ecx,11h
0040D811   mov         eax,0CCCCCCCCh
0040D816   rep stos    dword ptr [edi]
```

对于 `for` 语句的初始化

```
39:       for(int a=0;a <= 100;a++){
0040D818   mov         dword ptr [ebp-4],0  //把0写入局部变量a中
0040D81F   jmp         test_for+2Ah (0040d82a) //直接跳转到0040d82a  cmp dword ptr [ebp-4],64h
0040D821   mov         eax,dword ptr [ebp-4] //这里是a ++的执行过程
0040D824   add         eax,1
0040D827   mov         dword ptr [ebp-4],eax
0040D82A   cmp         dword ptr [ebp-4],64h //比较值
0040D82E   jg          test_for+43h (0040d843) //如果大 就退出for 0040D843   pop edi

```

可以发现中间有一个内容没有执行 所以我们继续看看 `for` 内部过程

```
40:           printf("%d",a);
0040D830   mov         ecx,dword ptr [ebp-4]
0040D833   push        ecx
0040D834   push        offset string "%d" (0042211c)
0040D839   call        printf (0040d720)  //这里都是函数调用过程
0040D83E   add         esp,8  //这保持堆栈平衡
41:       }
0040D841   jmp         test_for+21h (0040d821)  //无条件跳转到 a++ 的执行过程
42:   }

```

```
0040D843   pop         edi
0040D844   pop         esi
0040D845   pop         ebx
0040D846   add         esp,44h
0040D849   cmp         ebp,esp
0040D84B   call        __chkesp (004010e0)
0040D850   mov         esp,ebp
0040D852   pop         ebp
0040D853   ret

```

可以发现 `for`函数有许多的跳转 主要流程如下：

1. 直接赋值与比较 如果不满足 直接执行`for`语句
2. 执行完毕后 无条件跳转到 `a++`
3. 顺序执行继续判断 比较
