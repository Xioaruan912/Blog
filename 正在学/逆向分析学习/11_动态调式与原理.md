我们在学习 逆向过程中 静态分析完全不够 所以我们需要 动静结合分析

通过关键行为 从而定位关键函数

下述 是常见的 动态调试器

![image-20260126172204919](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260126172204919.png)

我们先要了解一下不同的步入方法

`单步步入`：每一行代码 执行 并且 如果调用函数 也进入函数内部

`单步步过`：每一行代码 执行 如果调用函数 不进入函数内部 而是依旧在本函数 执行流程中

调试器通过分析当前堆栈的地址 从而定位出 调用者是谁

# 原理

调试器是一个程序 而被调试程序是另一个程序 

调试器通过调用WIN32 API 函数 告诉操作系统 对某个进程调试

`int 3`：这是一条特殊的汇编指令 在 `x86`架构下 CPU 内部设一个寄存器 `IDTR` 指向 中断描述符表  有256项

![image-20260126183120641](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260126183120641.png)

中断描述符 指向一个 中断例程 

# 中断过程

![image-20260126183916485](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260126183916485.png)

执行到某个我们需要断的地址后 OS 触发 错误 插入 `INT 3` 从而触发

去 IDT表的第三个表项中 查找对应处理程序 从而被 调试器捕获 实现 调试

也就是` 0xcc`

调试器在断点处 会通过 CC 替换 但是不会 展示出来 是在背后进行替换的

# 单步调试

调试器 把 `Flag寄存器` 中的 `TF` 设置为1 CPU 每次执行一条 发现 TF 为1 就个语句都中断 实现单步调试

![image-20260126200721199](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260126200721199.png)

# 硬件条件断点

我们有的时候 需要通过变量监控 如果发生改变  就断住 如果用调试器 每次比对 就太消耗内存了 

在`X86` 架构下 存在硬件调试器

![image-20260126201000269](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260126201000269.png)

通过对` DR0-DR3` 设置条件 并且 在 `DR7` 中设置 是读还是写触发中断 就可以实现 条件断点过程

# `Ollydbg`

简称 `OD` 老牌动态调试工具

![image-20260129085924994](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129085924994.png)

默认`OD`停止在程序的入口处  这个方法是通过调试器启动 如果有应用已经启动了 我们可以通过`附加` 操作 附加到已经运行的程序中

主要窗口如下

![image-20260129090117415](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129090117415.png)

右侧是寄存器的 右下是 堆栈 左下是内存

![image-20260129090413367](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129090413367.png)

并且最上面的地址 总是跟着 `ESP`的值