# 进程与线程

进程是程序运行在内存的 内存映像  

程序是 静态在文件中的 

进程是 运行的程序 在内存中 一个程序可以运行多个进程

![image-20260129091745057](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129091745057.png)

# 进程内存地址空间

我们知道 32位计算机 

一个进程具有 `4GB的虚拟内存空间` 从 `0x00000000-0xFFFFFFFF` 并且划分为 `内核区`和`用户区`

对于内核区 操作系统是通过 共享映射的方法 而不是值拷贝

![image-20260129091949596](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129091949596.png)

一般情况下 程序不会分配到一个 内存页面 中 但是有的时候 DLL和PE会分配到一个只读的页面中

如果对于不只读的页面 但是被存入多个进程 那么我们需要严格的操作机制 否则会导致 其他进程 非法读取 `写时拷贝机制 COW`

# 写时拷贝机制 COW

检测到 写入共享的页面的时候 会导入一个新的页面 并且断开 共享属性 然后重新映射关系 最后写入

![image-20260129092336308](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129092336308.png)

可以发现 最后变为了 独立的多个页面

# 用户内存地址空间

大概用户内存如下图：

![image-20260129092446855](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129092446855.png)

# 线程

为了提高 速度 那么如果需要通信 就无法快速

`进程`：分配 系统资源的 最小单位

`线程`：执行的最小单位

线程有自己的栈 但是一个进程的所有线程 共享进程的 资源

![image-20260129092640566](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129092640566.png)

在CPU变为多核之后 线程的重要性就体现的淋漓尽致

# 构建进程

win32编程 主要通过` CreateProcessA/W 【区别时 A 时acsii w是unicode】`

![image-20260129092916319](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129092916319.png)

启动过程如下：

1. 加载对应的PE文件
2. 构架进程内存结构体 并且准备内存地址空间
3. 创建 `主线程`结构退 准备线程栈
4. 通知内核 可以调度线程

# 构建线程

![image-20260129093101331](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129093101331.png)

上面的 `CreateProcess` 在构建主线程的时候 也是调用这个 通过 `lpStartAdress` 用于表面 等等从哪里开始执行`【函数】`

# 进程启动分析

我们编写程序 都是从一个主入口 开始执行  但是我们需要了解 程序开始运行 是如何 找到`main` 并且执行用户代码的 这里就分析 

我们上述分析过程中提到了` CreateProcess` 通过构建 主线程 从而让 CPU运行 主线程 从而运行程序 这里就要分析主线程是什么了

## OEP后过程

OEP（Original Entry Point）即程序的原始入口点

我们之前学习PE文件的时候 学习了 程序一般 都是通过 `0x400000 ` 进入程序 这个地址 可不是 `main`函数的地址

我们可以通过 `PEID`程序分析

![image-20260129094036892](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129094036892.png)

这里的入口点 也就是程序执行的 第一条指令 通过` ImageBase + 入口点` 从而定位到 第一个指令

我们通过 VC6 看看 调用堆栈

![image-20260129094428701](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129094428701.png)

可以发现` main`是被`mainCRTStartup()` 函数所调用 这个函数是 `C/C++ runtime` 也就是C语言的运行函数库 用于执行所有C 编写的程序

所以过程就是 程序执行的时候 执行的第一个指令 是` mainCRTStartup` 的指令 这个函数是 PE自动链接进来的

![image-20260129094800573](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129094800573.png)

通过一系列初始化 最后执行 我们用户的 main函数

这里只是 C/C++ 程序在编程语言上走的路 那么 OS 走到 OEP 是如何走的呢

## OEP前过程

通过内核操作 实现找到 OEP