我们上面学习了 寻找OEP 也就是最简单的内容

这里我们还需要学习一个非常重要的内容 

# 导入表重建

我们首先说说原理

## 原理

在加壳原理的时候 我们知道 在加壳软件加壳中 会把 所有节都进行 加密压缩 那么导入表的 节 也会被压缩 从而win控制程序无法很好的找到目标模块导入 最后报错

所以一般的壳会 充当导入表和 win控制程序 不仅加密混淆 并且辅助程序导入  需要的模块

![image-20260212092825369](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260212092825369.png)

可以发现 它只导入了 很简单的函数 通过WIN32API 从而导入更多的API

也就是 外壳需要模仿PE加载器 去加载更多的DLL

# OD重建

在OD中 存在两个方法 重构导入表

![image-20260212093201146](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260212093201146.png) 

1. 通过IAT 反向推理出 导入表结构

如果我们通过 汇编可以发现 调用导入函数 一般通过` FF15` 的`call`实现

![image-20260212093451381](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260212093451381.png)

所以OD内部的 第一个方法 就是通过搜索这个 `FF15` 查找到 API 从而反向构建导入表

方法二 就是通过遍历 名字和信息 从而构建  准确性会降低

除了使用 OD插件 还可以使用` ImportREC` 工具实现重构

# `ImportREC`

首先我们需要不重建导入表 直接dump出 内存镜像

![image-20260212093751737](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260212093751737.png)

这里我们需要运行 导出的进程 

![image-20260212094603418](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260212094603418.png)

他会出现报错信息 然后我们通过` ImportREC` 附加 进行计算即可

![image-20260212094551549](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260212094551549.png)

有可能编译后的 IAT 是连续分布的 那么` ImportREC` 可以准确获取 

但是如果是下图

![image-20260212094720575](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260212094720575.png)

可以发现是不连续的 上面存在很多00 那么这个时候 我们需要计算 整个 地址大小 填入 `SIZE` 中 分析获取即可

# 重定位表-地址随机化

我们使用 vs2008 vs2019 编写的程序的时候 如果按照之前方法 操作 那么会直接无法运行 这是因为 WIN32 存在一个 重定位表

这是因为 启动的 地址空间随机化 ASRL 加载的基地址的变化 

由于 修改的地方很多 这就是重定位表 当前需要做的事情了 编译的时候 需要修正的 地方存入 重定位表中

在数据目录中 存放在 `.reloc` 节 中

所以我们dump出PE的时候 也需要 重新构建 重定位表 保证地址随机化

## 方法1 关闭地址随机化 

这最简单 最笨的方法 因为别人的程序我们依旧无法 很好调试

![image-20260212095917565](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260212095917565.png)

## 方法2 去除可选头标记

我们可以通过 `StudyPE` 工具

![image-20260212100053628](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260212100053628.png)

我们点击一下 就可以固定 其实本质也就是修改 PE标记

## 方法3 重构重定位表

这才是真正解决问题 我们可以通过 `ReloX` 重建重定位表

原理是 dump两个不同随机化的 PE 存入文件分析 分析完毕后通过算法 重建