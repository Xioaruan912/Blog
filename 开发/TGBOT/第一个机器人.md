首先去[@BotFather](https://telegram.me/botfather) 获取token

# 构建基本回复命令的Bot

首先我们看一个bot代码

```python
import logging
from telegram import Update
from telegram.ext import ApplicationBuilder, ContextTypes, CommandHandler

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await context.bot.send_message(chat_id=update.effective_chat.id, text="I'm a bot, please talk to me!")

if __name__ == '__main__':
    application = ApplicationBuilder().token('TOKEN').build()
    
    start_handler = CommandHandler('start', start)
    application.add_handler(start_handler)
    
    application.run_polling()
```

首先是一个logger库

```python
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
```

这里是 输出日志内容

下面是创建一个 Application 对象 传入token 用于注册机器人

[ `telegram.ext.ApplicationBuilder`](https://docs.python-telegram-bot.org/telegram.ext.applicationbuilder.html#telegram-ext-applicationbuilder) 这里是建立app

[`telegram.ext.Application`](https://docs.python-telegram-bot.org/telegram.ext.application.html#telegram.ext.Application) 这里是对象的具体内容

```python
    application = ApplicationBuilder().token('TOKEN').build()
```

只有这个app还无法做任何事情 我们直到 传入/命令就可以执行

所以现在我们注册一个start命令

```python
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await context.bot.send_message(
        chat_id=update.effective_chat.id,
        text="I'm a bot, please talk to me!"
    )
```

每次调用/start 就会执行代码

```
update 包含来自 Telegram 的所有信息和数据（如消息、发出命令的用户等）
context，它是一个包含有关库自身状态的信息和数据（如 Bot、Application、job_queue 等）的对象
```

[`telegram.Update`（更新参数的类型）](https://docs.python-telegram-bot.org/telegram.update.html)

[`telegram.ext.CallbackContext`（上下文参数的类型）](https://docs.python-telegram-bot.org/telegram.ext.callbackcontext.html)

构建完毕命令代码我们去调用bot监听命令

```python
from telegram.ext import CommandHandler
start_handler = CommandHandler('start', start)
application.add_handler(start_handler)
```

[`telegram.ext.CommandHandler`](http://docs.python-telegram-bot.org/telegram.ext.commandhandler.html)

 [`telegram.ext.Application.add_handler`](http://docs.python-telegram-bot.org/telegram.ext.application.html#telegram.ext.Application.add_handler)

最后

```python
application.run_polling()
```

会让bot执行

但是现在只有一个命令会响应 如果我们需要另一个命令就注册另一个函数实现

```python

async def echo(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await context.bot.send_message(chat_id=update.effective_chat.id, text=update.message.text)
```

```python
    application.add_handler(echo_handler)
```

具体text的内容我们可以通过[`telegram.Update`](https://docs.python-telegram-bot.org/telegram.bot.html#telegram.Bot.send_message) 查看



# 构建带有参数的Bot

```python
async def caps(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text_caps = ' '.join(context.args).upper()
    await context.bot.send_message(chat_id=update.effective_chat.id, text=text_caps)
```

这里通过context.args 获取参数 并且返回大写 回复给bot

# 内嵌机器人

[内嵌模式](https://core.telegram.org/bots/inline)

就是我们在输入内容的时候 已经在调用函数实现了

```python
from telegram import InlineQueryResultArticle, InputTextMessageContent
from telegram.ext import InlineQueryHandler

from uuid import uuid4

...

async def inline_caps(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.inline_query.query  
    if not query:
        return
    results = []
    results.append(
        InlineQueryResultArticle(
            id=str(uuid4()),
            title='Caps',
            input_message_content=InputTextMessageContent(query.upper())
        )
    )
    await context.bot.answer_inline_query(update.inline_query.id, results)

if __name__ == '__main__':
    ...
    inline_caps_handler = InlineQueryHandler(inline_caps)
    application.add_handler(inline_caps_handler)

    application.run_polling()
```

我们通过下面的代码获取内嵌的语句

```python
    query = update.inline_query.query  
```

这里是构建回复内容的

```python
 results.append(
        InlineQueryResultArticle(
            id=str(uuid4()),
            title='Caps',
            input_message_content=InputTextMessageContent(query.upper())
        )
    )
```

[telegram.ext.InlineQueryHandler](http://docs.python-telegram-bot.org/telegram.ext.inlinequeryhandler.html)

 [answer_inline_query](https://docs.python-telegram-bot.org/telegram.bot.html#telegram.Bot.answer_inline_query)

# 处理错误指令

```python
async def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await context.bot.send_message(chat_id=update.effective_chat.id, text="Sorry, I didn't understand that command.")

```

用于指令兜底 此处理程序*必须*最后添加

