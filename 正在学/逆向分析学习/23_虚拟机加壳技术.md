也是静态保护方法

VMP也就是大名鼎鼎的虚拟机技术

对于之前的加壳方法 最简单的就是不分析壳

![image-20260211112454197](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211112454197.png)

通过内存中找到解密 然后直接`DUMP`出 那么就和原本分析一样过程了

# 原理

虚拟机技术 那么一定离不开机器 所以虚拟机技术存在一些要素

1. 需要一套虚拟的指令集
2. 每条指令的软件模拟实现 叫做`Handler`
3. 一个指令寄存器 用于指示 下一条指令
4. 调度器 依据不同的指令 调度不同的` Handler`
5. 编译器 把原本CPU的内容转化为虚拟机指令

虚拟机保护技术就是 把原本的指令集 修改为虚拟机的内容 然后通过虚拟机执行

![image-20260211112900266](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211112900266.png)

这样 目标文件中就不存在 CPU指令 而是修改后的虚拟机指令 反编译难度大 并且不会在内存中增加 解密过程 从而不会被`dump`

## 虚拟机保护的弊端

当然是臃肿 如果只是为了输出一个HelloWorld 那么这个虚拟机技术不仅 拖慢 执行速度 并且内存占用大

所以一般都是用于核心代码处 并且配合加壳技术 结合使用

## 执行思想

```
mov eax,dword ptr [esp+4]
mov ebx,dword ptr [esp+8]
add eax,ebx
```

用C语言写就是普通的加法函数

```c
int add(int a,int b){
	return a+b;
}
```

虚拟机技术简单可以这样操作 

直接设置3个机器码 `01` `02` `03`

`01`：读取堆栈 ESP+4 存入`eax`

`02`：读取堆栈 ESP+8 存入`ebx`

`03`：eax和ebx做加法指令 写入eax

那么通过下述代码

```c
typedef unsigned char byte;
int interpreter(){
	while(true){
	byte byte_code = get_byte(); //内存中获取一个字节
	switch(byte_code){
	case 0x01:
		handler_01();
		break;
	case 0x02:
		handler_02();
		break;
	case 0x03:
		handler_03();
		break;
	default:
		printf("error\n");
	}
	}
}
```

最后配合上不同处理函数

```c
__declspec(naked)
void handler_01(){
	__asm{
		mov eax,dword ptr [esp+4]
	}
}
__declspec(naked)
void handler_02(){
	__asm{
		mov ebx,dword ptr [esp+8]
	}
}
__declspec(naked)
void handler_03(){
	__asm{
		add eax,ebx
	}
}
```

这就实现了这个过程 这个只是最简单 的例子  可以发现还是执行原本的指令 花时间还是可以分析出来的

下面是一个真实的虚拟机例子

![image-20260211113837288](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211113837288.png)

```
push 虚拟的字节码地址 //这里是我们虚拟机加密后的字节码地址
jmp VSstartVM 
```

上述代码是 启动 `VStartVM`的执行过程 直接通过`JMP` 所以不存在函数调用

```
VStartVM:
push eax
push ebx
push ecx
push edx
push esi
push edi
push ebp
pushfd //这个是压入 eflag寄存器
mov esi,[esp+0x20] //这里就是把栈的指针 转向上面压入的 虚拟的字节码地址
mov ebp,esp
sub esp,0xC8 //扩大栈的空间
mov edi,esp
```

上述代码执行完毕后会继续执行 调度器

```
VMDispatcher: //VM的调度器
 movzx eax,byte ptr[esi]  //读取 虚拟化后的 代码一个字节 高位填充0
 lea esi,[esi+1] // esi + 1
 jmp dword ptr [eax*4 + JMPADDR]
```

`JMPADDR`也就是一个大数组 保存着 处理函数

![image-20260211114608229](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211114608229.png)

为了防止 指令执行过程中修改 寄存器导致 虚拟技术胡乱 所以我们需要重新设置一个独立的寄存器系统

```
struct VMcontext{
	DWROD v_eax
	DWROD v_ebx
	DWROD v_ecx
	DWROD v_edx
	DWROD v_esi
	DWROD v_edi
	DWROD v_edp
	DWROD v_efl
}
```

可以写入 堆 或者栈【主要】

这里是通过第一个Handler 处理的

![image-20260211114946200](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211114946200.png)

这里对栈操作的 处理 都需要跳转到 `vCheckESP` handler 处理检查栈的大小等

# handler的设计

分为`指令handler`和`辅助handler`

![image-20260211115223397](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211115223397.png)

虚拟化过程

```
add eax,0x1234
```

![image-20260211115358055](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211115358055.png)通过这些代码的结合 实现一个加法指令

这就是最简单的 虚拟保护技术了

可以发现 很臃肿 所以我们一般是保护核心代码

![image-20260211115517869](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260211115517869.png)