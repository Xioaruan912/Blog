编程都是各个函数之间的调用 所以这个是必须学习的

1. 调用者函数`(main)` 如何把本地自己的参数 传递给 被调用的函数`(func)`
2. 被调用者函数`（func）` 如何把 运算结果 返回给 调用函数`（main）`

# 函数调用约定

为了解决上述问题 约定一些规则 从而实现函数调用 这就是函数调用约定 常见的 `win` 下函数约定有下述：

`__cdecl`：VC++ 默认使用的函数调用约定 通过`堆栈`传递 通过`从右向左`传递参数 由` 调用者函数（main）`负责释放`被调用函数（func）内存` 函数返回值通过`寄存器 `返回

`__stdcall`：通过`堆栈`传递 通过`从右向左`传递参数 函数返回值通过`寄存器 `返回 由` 被调用函数（func）`负责释放`内存` 

`fastcall`：通过`寄存器`传递，前面`两个参数`通过寄存器 其余通过`从右向左`向堆栈传递传递参数 函数返回值通过`寄存器 `返回 由` 被调用函数（func）`负责释放`内存` 

# `__cdecl`函数调用过程



```c
#include <stdio.h>

void __cdecl do_while_test(int a,int b){
	do 
	{
		printf("%d",a--);
	} while (a);
}


int main(){
	int a=10;
	int b=10;
	do_while_test(a,b);
	return 0;
}
```

我们通过上述代码 声明 通过 `__cdecl`  实现函数调用 下面是 `main`函数中 调用函数的方法 首先 存入`寄存器` 通过寄存器压入栈

```
14:       do_while_test(a,b);
004010B6   mov         eax,dword ptr [ebp-8]
004010B9   push        eax
004010BA   mov         ecx,dword ptr [ebp-4]
004010BD   push        ecx
004010BE   call        @ILT+0(do_while_test) (00401005)

```

我们知道 栈从高地址生长到低地址 所以这里会被压入 `[ebp-12]` `[ebp-16]` 中 并且从右往左 先传递` b `后传递` a` 然后执行函数调用

我们之前学了 `call` 本质上就是一个 `push EIP`   一个 无条件跳转指令 所以这里会直接调转到 `do_while_test` 函数中 

我们可以查看一下 被调用的首尾

```
3:    void __cdecl do_while_test(int a,int b){
00401020   push        ebp

...


0040106D   pop         ebp
0040106E   ret
```

我们知道 `ret` 是通过`pop EIP`然后无条件跳转实现  下面是 `main` 函数结尾 可以发现通过 `ebp+8` 删除传递的参数

```
004010C3   add         esp,8
15:       return 0;
004010C6   xor         eax,eax
16:   }

```

所以下述内容可以用动图实现

![Capturer_2026-01-23_112220_766](https://raw.githubusercontent.com/Xioaruan912/pic/main/Capturer_2026-01-23_112220_766.gif)



 

# `__stdcall`函数调用约定

```c
#include <stdio.h>

void __stdcall do_while_test(int a,int b){
	do 
	{
		printf("%d",a--);
	} while (a);
}


int main(){
	int a=10;
	int b=10;
	do_while_test(a,b);
	return 0;
}
```

可以发现 没有实现 `ebp+8`

```
14:       do_while_test(a,b);
004010B6   mov         eax,dword ptr [ebp-8]
004010B9   push        eax
004010BA   mov         ecx,dword ptr [ebp-4]
004010BD   push        ecx
004010BE   call        @ILT+10(do_while_test) (0040100f)
15:       return 0;
004010C3   xor         eax,eax
```

下面是`do_while_test`函数的 结尾

```
0040106D   pop         ebp
0040106E   ret         8
```

这个 `ret 8`  类似如下操作

```
pop EIP
add ESP,8
jmp xxx
```

这就是 `__stdcall` 调用约定 主要就是 谁来清理内存

# `__fastcall`函数调用约定

```c
#include <stdio.h>

void __fastcall	 do_while_test(int a,int b){
	do 
	{
		printf("%d",a--);
	} while (a);
}


int main(){
	int a=10;
	int b=10;
	do_while_test(a,b);
	return 0;
}
```

我们看看 `main`函数中

```
14:       do_while_test(a,b);
004010B6   mov         edx,dword ptr [ebp-8]
004010B9   mov         ecx,dword ptr [ebp-4]
004010BC   call        @ILT+15(do_while_test) (00401014)
15:       return 0;
004010C1   xor         eax,eax

```

直接通过 `edx `和` ecx `传递参数 我们进入 `do_while_test` 看看

```
00401075   pop         ebp
00401076   ret
```

由于不通过栈传递参数 所以 栈内存的清理 不需要 `pop ebp`完后就栈中就没内容了

# 返回值

都是通过 `eax` 取得返回值内容

# 栈帧布局

一个函数的局部变量 是怎么分布的  

## 被调用函数执行过程

```
3:    void __cdecl do_while_test(int a,int b){
00401020   push        ebp
00401021   mov         ebp,esp
00401023   sub         esp,44h
00401026   push        ebx
00401027   push        esi
00401028   push        edi
00401029   lea         edi,[ebp-44h]
0040102C   mov         ecx,11h
00401031   mov         eax,0CCCCCCCCh
00401036   rep stos    dword ptr [edi]
```

1. 首先保护现场 把`main`的栈低压入栈 然后初始化 `do_while_test`的栈 `push ebp` 和 `mov ebp,esp` 
2. 初始化自己的栈帧空间 `sub esp,44h`
3. 保存被调用者需要保护的寄存器 因为函数内部可能会用这些寄存器干活，但调用者期望函数返回后这些寄存器值不变，所以先压栈保存
4. `lea edi, [ebp-44h]` 局部变量区域的起始地址（`ebp-0x44`）放进 `EDI`
5. 设置计数器`ecx = 0x11 = 17` 为了下面填充初始化栈帧数据
6. 把整个局部变量区填成` 0xCCCCCCCC` 这里是因为 我们通过 `Debug模式`

我们这里通过图像来展示过程

![Capturer_2026-01-23_115317_468](https://raw.githubusercontent.com/Xioaruan912/pic/main/Capturer_2026-01-23_115317_468.gif)

中间抬高的` 44h ` 就是用于存放 局部变量的

通过值拷贝 把 `main` `ebp+8` `ebp+C`的传递参数 存储到 寄存器中 运算结果 通过栈方法存放到` 44h`中

例如我们通过 `3+4` 保存到`c`中

![image-20260123114607417](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260123114607417.png)

# 注意

1. 不同编译器 结果不同
2. 同样编译器 开启优化和不开启优化 结果也不同
3. 同样编译器 同样优化 32位和64位 结果也不同
