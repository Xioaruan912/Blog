C++中包含 `char类型` 或者 `char[] `代表字符串 通过 ASCII编码

如果我们需要兼容性 那么这个就无法在 `unicode编码中使用`

也就是如果使用汉字 那么就无法全部兼容使用

所以 C++  又使用 `wchar_t` 也就是2字节 

格式如下 我们需要在字符前面添加一个 `L` 规定了 是`wchar_t`类型 否则默认使用 `char类型` 代替

```c++
wchar_t wct = L'A';

wprintf(L"%c",wct);

wchar_t wc[] = L"Hello World";
```

VS 默认使用  `unicode`

![image-20260204124715316](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260204124715316.png)

我们知道 win32 API 存在` A `和` W` 两个版本 `CreateFileA`  `CreateFileW`

![image-20260204124821507](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260204124821507.png)

所以我们在写 win32的时候 都需要注意 并且 win32最后都是走的` W` 版本

也就是只要有字符串的操作 那么就需要 区分

# 编码规则

编写 win32 最好使用 `unicode`

我们在之前写的时候可以发现

```
CreateFile("C:\\1.txt",0,0,0,0,0,0)
```

会被报错 如果我们使用` unicode` 那么我们需要添加 `L` 这就很麻烦 所以 win32 定义出一个 自动随配置切换的类型` TCHAR`

```C++
TCHAR tch = "C:\\1.txt";
CreateFile(tch,0,0,0,0,0,0);
```

但是这个方法 依旧存在问题 如果我就是想写死在` Createfile`中 而不是变量 那么就可以通过下面方法实现

```
CreateFile(TEXT("C:\\1.txt"),0,0,0,0,0,0);
```

会自动随配置 修改

我们可以通过 IDA 打开 `kernelBase.dll` 由于` kernel32 `是转发 到` kernelBase`的 所以我们需要分析的是 `kernelBase.dll`

![image-20260204130427802](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260204130427802.png)

可以发现 只有 `CreateFileA和W版本` 没有`createFile`

现在版本 是通过` CreateFileinternal `实现的

所以我们 使用 `TCHAR` 和 `CreateFile` 这种宏定义 构建项目即可

# 字符处理

上述 win32 自己的 定义 无法使用 普通的` strlen`这种 所以我们可以通过双向的 `lstrlen` 实现自己的分析

如果我想把`ASCII` 转 `unicode` 那么需要字符转化

```
MuLitByteToWideChar()
```

直接转化