Go是面向接口的语言 主要构建结构实现

![image-20251228110917572](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251228110917572.png)

# Duck Typing

![image-20251228110941997](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251228110941997.png)

duck typing: 像鸭子走 像鸭子叫 就是鸭子

正常理解： 没有声明 不是鸭子

```
描述事务的外部行为 而非内部结构
```

所以 我们Go中 忽略内部细节 注重 你给出的东西

`Python`中的duck typing

![image-20251228111146088](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251228111146088.png)

`C++`中的duck typing

![image-20251228111248176](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251228111248176.png)

# 接口定义

![image-20251228111522159](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20251228111522159.png)

我们规定 download 使用 retriever实现

```
接口通过 使用者定义
```

```go
package main

import (
	"fmt"
	"test/mock"
)

// 定义接口
type Retriever interface {
	Get(url string) string
}

func download(r Retriever) string {
	return r.Get("https://csdn.im")
}

func main() {
	var r Retriever
	r = mock.Retriever{}
	fmt.Println(download(r))
}

```

```go
package mock

import (
	"net/http"
	"net/http/httputil"
	"time"
)

// 定义Retriever 内部结构
type Retriever struct {
	Useragent string
	Timeout   time.Duration
}

// 实现接口内方法
func (r Retriever) Get(url string) string {
	resp, err := http.Get(url)
	defer resp.Body.Close()
	if err != nil {
		panic(err)
	}
	res, err := httputil.DumpResponse(resp, true)

	if err != nil {
		panic(err)
	}
	return string(res)
}

```

从上述可以发现 我们的`mock`实现者 只需要实现方法即可

```
func (r Retriever) Get(url string) string
```

使用者 要求定义出 我需要什么东西

```
// 定义接口
type Retriever interface {
	Get(url string) string
}
```

这样就分离开来

```
我们需要调用接口的人 只需要 写自己的 接口 和 所使用的函数
实现者 只需要完成函数的定义 而忽略 其他外部内容
```

# 接口的值类型

我们可以看看r 内部是什么东西

```
var r Retriever
```

```go
func main() {
	var r Retriever
	r = mock.Retriever{
		Useragent: "Mozilla",
		Timeout:   time.Minute,
	}
	fmt.Printf("%T %v", r, r) //展示 类型和值
}
```

```
mock.Retriever {Mozilla 1m0s}
```

可以发现内部是这样的 这样是拷贝的 如果通过 指针也可  

