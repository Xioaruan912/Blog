有些资源是成对出现的

# defer

确保在函数结束的时候 结束调用

```go
package main

import "fmt"

func tryDefer() {
	defer fmt.Println("1") //推迟到return之前确保执行
	fmt.Println("2")
}

func main() {
	tryDefer()
}

```

defer内部是一个栈 FILO 所以 如果使用多defer 那么就是 最后的那个defer先执行

```go
package main

import "fmt"

func tryDefer() {
	defer fmt.Println("1")
	defer fmt.Println("1.5")
	fmt.Println("2")
}

func main() {
	tryDefer()
}

```

```
2
1.5
1
```

# 资源管理

```go
package main

import (
	"bufio"
	"fmt"
	"os"
)

func WriteFile(filename string) {
	file, err := os.Create(filename)
	if err != nil {
		panic("File exited")
	}
	defer file.Close() //写完就想到需要关掉

	//导入 buf中
	write := bufio.NewWriter(file)
	defer write.Flush() //想到写入缓冲区后 需要写入文件中
	for i := 0; i < 20; i++ {
		fmt.Fprintln(write, i)
	}
}

func main() {
	WriteFile("1.txt")
}

```



