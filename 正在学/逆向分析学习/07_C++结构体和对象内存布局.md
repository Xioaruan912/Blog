这个很重要 我们逆向分析过程中 很多都是 基于 面向对象的 所以我们需要有能力 

反汇编出结构体 但是 IDA 并不会 直接把结构体返回 而是返回定义出的数据类型 所以我们需要还原

# 占用大小

我们看看基本数据类型的 字节数

![image-20260124091150242](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124091150242.png)

下述是一个 对象

```c
class Child{
	int age; //4字节
	char sex; //1字节
};
```

这里其实占用的是`8`个字节 因为编译器会让数据 按照 内存对齐  方式存储 从而让`IO`次数变少 也就是一次正好可以 读取 4字节

![image-20260124091330959](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124091330959.png)

## 内存对齐

1. 数据的起始地址 必须是自己类型的整数倍
2. 结构体和对象的对齐值 必须是 内部成员 大小最大的 值

按照上述内存对齐 规则

```c
class Child{
	int age; //4字节
	char sex; //1字节
	short num; // 2字节
};
```

可以发现内存排布如下图所示

![image-20260124091628997](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124091628997.png)

## 带有虚函数

如果结构体内部带有一个虚函数

```c
class Child{
	int age; //4字节
	char sex; //1字节
	virtual void talk(){
		printf("hello");
	}
};
```

会存在一个 隐含指针 指向 虚函数表 从而定位出 虚函数地址

![image-20260124092246604](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124092246604.png)

## 要求不优化

这里在网络通信过程 的实现 有下述要求 由于 协议精确到了`bit `所以 要求不允许内存对齐

```c
#pragma pack(1)  //设置对齐大小为1
class Child{
	int age; //4字节
	char sex; //1字节
	virtual void talk(){
		printf("hello");
	}
};
#pragma pack()
```

![image-20260124092436820](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260124092436820.png)