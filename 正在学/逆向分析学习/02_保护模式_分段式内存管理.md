为了解决安全问题以及寻址问题 推出了80386 CPU 进入了 32位时代

寄存器如下图：

![image-20260121224954108](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260121224954108.png)

名字增加了一个 E(`extend`)

为了系列机的兼容 寄存器 依旧可以被当作 16位访问

![image-20260121225036872](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260121225036872.png)

32位寄存器 可以寻址 `2^32 = 4GB`

# 分段式寻址

实模式也是一个分段式寻址 通过 DS SS CS等 去寻址

但是不安全 理论上 可以访问整个内存 OS 无权干涉

## 保护模式

这个是32位CPU 推出的全新寻址模式

首先 每个段 组合成一个 表格

 ![image-20260122084315945](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122084315945.png)

段寄存器  存储的 是 行号 通过 行号 + 偏移量 赋值给 

通过这个方法访问

![image-20260122084413417](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122084413417.png)

# CPU的权限级别

x86 我们听过许多 环数 如下图

![image-20260122084453727](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122084453727.png)

0环也就是 内核程序

1 2 环也就是 驱动程序

3环 是应用程序

【`win`和`linux`】都使用了 0和3环 驱动和内核都在0环

我们上面知道了中转 那么就可以和 大学课程 OS 学习的 分段式管理一样 通过一个 地址转化机构

实现界地址约束 从而不允许越权 并且通过权限约束



![image-20260122084744282](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122084744282.png)

段寄存器 包含2bit位的 特权级 也就是 CPL 表示当前访问的特权

段表中 包含 DPL 也就是目标段的特权级 

OS访问过程 会比对两个特权是否符合 如果符合 那么就允许访问

# 本地表

x86架构 还设置了 不同的表 表示 全局和本地 并且把	段寄存器修改如下：

![image-20260122085036591](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122085036591.png)

16位的段寄存器 变为了 13 1 2 格式 13表示行号

![image-20260122085140877](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122085140877.png)

设置两个指向不同表的 GDTR 也就是 `Global` 全局 `LDTR` 也就是 `Local`

访问过程如下：

1. CPU给出段寄存器数值 通过硬件拆分为 13 1 2 的格式
2. 通过 表指示位 是1 或者0 去访问 全局 还是本地表
3. 通过行号 得到表的行 从而得到基地址
4. 对比权限 如果相同 则允许
5. 最后和偏移 相加 得到真实地址

在段描述符中 内容如下

![image-20260122085418894](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122085418894.png)

# 弊端

解决了 权限问题

但是还是没用解决 多进程隔离问题
