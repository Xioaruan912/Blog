实模式下 公用 1MB的内存空间  并且唯一地址的 数据可以被不同进程看见

如果不同进程修改 一个地址的内容 那么全局的进程访问这个地址都是修改后的 安全性极差

# 分页式内存

OS 告诉进程 "独占" 4GB 内存空间  也就推出了 虚拟存储器

首先 OS 划分 内存为 大小相同的页 每个页的地址 存储在页表中

进程也按照同样大小划分为页

当程序准备运行的时候 OS 会预先存储一些 页在内存中

进程运行的时候OS 只需要 调入几个页面 并且通过 地址转化机构 实现转化

![image-20260122090140140](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122090140140.png)

所以 进程看见的地址空间 是 虚拟地址空间 	并且通过 调度实现页面的更替

![image-20260122090315354](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122090315354.png)

如果一个页面过大 那么就产生了多级页式内存管理

![image-20260122090436693](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122090436693.png)

X86通过专门的 寄存器 `CR3` 指向页目录文件

我们可以通过 VC++ 构建一个基本的代码

```
通过网盘分享的文件：vc++6.0和visual assist
链接: https://pan.baidu.com/s/1e-vYNFM3BF60_pixFhi0Iw?pwd=3gx5
```

![image-20260122091431928](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122091431928.png)

分析如下

```
CS = 0023 转化二进制为 00000000 0010 0011
DS = 002B 转化二进制为 00000000 0010 1011
ES = 002B 转化二进制为 00000000 0010 1011
```

我们之前知道 段寄存器的布局 转化一下

![image-20260122085036591](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122085036591.png)

```
CS = 0000000000100 0 11
DS = 0000000000101 0 11
ES = 0000000000101 0 11
```

说明 `CS` 指向全局表 并且是 3级权限【3环】

我们可以通过 `PChunter` 获取内核的 `DTR` 【也可以使用 https://github.com/ClownQq/YDArk/tree/master】 

这里推荐通过 VM 打开一个 win7虚拟机分析 可以节省很多问题

![image-20260122094155028](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122094155028.png)

`CPU序号` 表示是CPU的哪个核心 每个核都有GDT表

![image-20260122094303857](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260122094303857.png)

从这里可以看见 都是全部的4GB内存空间 所以说 

![image-20260121224612653](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260121224612653.png)

这四个段在 OS 过程中是 占用整个 4GB的 也是虚拟的