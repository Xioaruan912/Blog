方法是作用于特定类型（Receiver)变量的函数

也就是类似其他编程语言的 `this`和 `self`

```
func (接收者变量 接收者类型) 方法名(参数)(返回值){
	函数体
}
```

```go
package main

import "fmt"

type person struct {
	age  int8
	name string
	city string
}

//Dream的接收者是 person类型的 所以只要是person类型 就可以调用这个方法
func (p person) Dream() {
	fmt.Println("做梦")
}

func main() {
	var p person
	p.Dream()
}

```

# 值类型和指针类型

如果我们不修改 结构体里面的内容 那么就通过值类型 如果要修改 就要传入 值类型

```go
package main

import "fmt"

type person struct {
	age  int8
	name string
	city string
}

func (p person) Dream() {
	fmt.Println("做梦")
	p.age = 123
}

func main() {
	p := person{111, "asd", "d"}
	p.Dream()
	fmt.Println(p.age)
}

```

这里是值类型 所以我们输出结果看看：

```
做梦
111
```

如果我们需要修改 那么我们需要通过指针传递

```go
package main

import "fmt"

type person struct {
	age  int8
	name string
	city string
}

func (p *person) Dream() {
	fmt.Println("做梦")
	p.age = 123
}

func main() {
	p := person{111, "asd", "d"}
	p.Dream()
	fmt.Println(p.age)
}

```

可以发现 添加了 指针后 修改结果完全不同：

```
做梦
123
```

# 任意类型添加方法

之前我们学了 自定义类型 `go` 可以为 `本包`的类型 定义方法

别的包 不允许

```go
type myint int;

func(m myint) Say(){
	fmt.pln("he")
}

func main(){
	var m1 myint
	m1.Say()
}
```

# 结构体的匿名字段

```go
package main

import "fmt"

type person struct {
	int8 //这里就是匿名字段
	name string
}
```

使用方法：

```go
func main() {
	p := person{111, "asd"}
	p.Dream()
	fmt.Println(p.int)
}
```

可以 发现 其实都是一样的

 不允许 “一个类型出现多个匿名字段同名”

# 嵌套结构体

```go
package main

type Add struct {
	Province string
	City     string
}

type person struct {
	age  int8
	name string
	city Add
}

```

# 结构体的继承

```go
package main

type Add struct {
    Province string
    City     string
}

type person struct {
    age  int8
    name string
    city Add
}
```

# 结构体的可见性

首字母大写 就是公开访问 小写就是 只有本结构体内部私有的