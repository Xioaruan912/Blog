我们需要学习 通过 GUI 方法 的内容 我们主要了解的 是通过 C++ 编写的` winGUI`程序

# 消息机制

之前我们写控制台程序 都是从 内核 到 C++语言环境 最后到 `Main` 执行完毕后 就退出了

`windows图像界面程序` 是基于`消息驱动运行`的 我们执行的任何操作 都是一个消息 

![image-20260129230658251](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129230658251.png)

应用程序不断取出 消息 并且响应 否则等待

## 入口函数

我们写一个控制台 是通过 `main`开始 但是 控制台程序 是从` wmain`开始的

![image-20260129230748376](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260129230748376.png)

```c++
//入口程序
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
 	// TODO: Place code here.
	MSG msg;
	HACCEL hAccelTable;

	//这里加载字符串 通过 loadstring 加载字符串
	LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING);
	LoadString(hInstance, IDC_WWWW231, szWindowClass, MAX_LOADSTRING);

	//注册一个窗口类
	MyRegisterClass(hInstance);

	// 检测 窗口是否打开 如果没有打开返回错误
	if (!InitInstance (hInstance, nCmdShow)) 
	{
		return FALSE;
	}
	
	//设置 快捷键内容 可以忽略
	hAccelTable = LoadAccelerators(hInstance, (LPCTSTR)IDC_WWWW231);

	// 主要消息循环
	while (GetMessage(&msg, NULL, 0, 0)) 
	{
		if (!TranslateAccelerator(msg.hwnd, hAccelTable, &msg)) 
		{
            //翻译消息 编码
			TranslateMessage(&msg);
            //分发消息
			DispatchMessage(&msg);
		}
	}

	return msg.wParam;
}

```

这就是一个简单的 `win32API `程序

在我们点击关闭窗口的时候 发出 `WM_QUIT` 代表 窗口关闭 从而退出` while` 【因为这里 `GetMessage`会返回0】

其他内容 我们需要去学习` win32API内容` 一般都是通过查询实现

# 句柄

`HANDLE` 就是我们说的句柄 是windows程序的基础 我们叫做内核对象

```
typedef void *HANDLE;
```

我们通过查找可以发现 就是一个指针(索引)

操作系统通过下图实现 对象控制

![image-20260202174416389](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260202174416389.png)

句柄是进程的概念 也就是说 一个进程的相同句柄 可能指向的对象是不同的

# MFC

我们看见之间通过 win32 开发桌面程序很困难 所以提出了 MFC

![image-20260202174751457](https://raw.githubusercontent.com/Xioaruan912/pic/main/image-20260202174751457.png)

可以发现和易语言一样 通过简单的面板 拖拽 就可以开发自己的 内容